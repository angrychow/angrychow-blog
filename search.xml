<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>由 ChatGPT 帮我写代码所想到的</title>
      <link href="/angrychow-blog/2023/05/31/endless-industrial-revolution/"/>
      <url>/angrychow-blog/2023/05/31/endless-industrial-revolution/</url>
      
        <content type="html"><![CDATA[<p>大二下接近尾声，诸多课设“开发”任务的 Deadline 也开始逼近。java OOP 课程要求写一个聊天系统，我负责写客户端部分。客户端用的是 java swing （一门也许比我年纪还大的技术）进行开发。我翻了翻 Oracle 提供的 java swing 文档 —— 不出意料，我几乎很难看懂上面写的每一个字。于是，我转向 ChatGPT 求助。一开始，我只是向 ChatGPT 问问具体类的成员方法的用处之类的；后来我渐渐发现，只要我输入的 Prompt 足够细致，我可以让 ChatGPT 直接帮我生成一个窗口出来。java OOP 课程还布置了十道需要在 Online Judge 上完成的编程题，ChatGPT 能够直接正确的回答其中的七道题，另外三道题在我稍稍调整后也通过了 Online Judge 的评判。</p><p>就在昨天，我看见一位朋友写的数据结构课程设计的前端页面 —— 在我看来，写的挺像模像样的。本人身边的朋友多数不太喜欢做图形界面开发，所以我一直在“查找”身边的做过客户端或者前端开发的同学。经过一番交谈，我发现这位朋友的前端技术也是“速成”出来的 —— 这位朋友花了大约两个月的时间首先了解了 html，css，js 的一些大致开发功能，之后在 “B 站大学” 学习了一下 vue 框架的运作模式（为什么这些机构不愿意多录制一点 React 的教学视频？React 可比 vue 好学多了），最终，在 GPT 4 老师的帮助下，这位同学迅速形成了一套<strong>可行的，可用的，界面美观的前端页面</strong>。</p><p>这使我感到有一些震惊，虽然我本人也是经常依赖 ChatGPT，可是我没想到 ChatGPT 竟然能使一位没有过前端开发经历的人在这么快的时间内做出来这么一套东西。回想起我第一次开发前端，一路上有无数的挫折……我现在还能想起来，2021 年 12 月，那时的我是多么困惑于 React 中的那个玄妙的“副作用”！（拜 B 站缺少 React Hook 的教学视频所赐！）</p><p>在没有 GPT 的帮助的日子里，我大约花了半年的时间（2022.1 ~ 2022.7）才大概理解了前端开发的一些要点，并且可以自己写出一些功能没那么复杂的网页（还必须有厉害的人能在旁边提点我几句，不然遇到问题就卡壳了）。之后，我又花了半年时间（2022.9~2023.5），理解了 JavaScript 重要的一些语言特性（单线程异步，原型链等），大致了解了一些“大前端”的开发框架（例如 Electron，React Native），又实际上手做了一两个比较完备的前端项目 —— 到这时，我才大概能够独立的开发出一点可以用的前端页面和基于前端工具链的一些应用。</p><p>而现在，有了 ChatGPT，前端开发变得更加的简单了，你都不需要对框架的细节有过多的掌控，你只需要大概的了解这个框架的核心概念（如果你不知道这些核心概念，那你就没办法写 Prompt 了，这个懒 ChatGPT 还暂时不能帮你偷），就可以役使 ChatGPT 帮你生成代码，你再调一调就可以把代码写出来了。<strong>ChatGPT，我想，他最大的好处就在于，他把我们从具体工程中的漫天文档中解救出来，让我们不用关心那么多繁冗的细节。</strong>在没有 ChatGPT 的时候，开发者形成对这些繁冗细节的良好理解力的最好的方式是积累开发的经验 —— 然而 ChatGPT 的出现正好让一个缺乏具体开发经验的人也能写出来一个不错的项目。</p><p>在这篇短文里，我也不想发出类似于“前端已死！”这样的感叹 —— 一来我的资历仍然还是浅薄的很，并不支撑我做如此论断，二来天天呼喊“狼来了”也纯属庸人自扰，徒引人发笑耳。</p><p>只是，ChatGPT 强大的功能，让我构想出第三次工业革命时期的一个画面：<strong>一位原本自得于娴熟操纵复杂机械的工人，看着一台袖珍的计算机用密密麻麻的电线向机械以一秒钟上万次的频率控制着机器，心中暗忖自己这几十年的“技术”算是白干了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是谁让你去淄博吃烧烤的？</title>
      <link href="/angrychow-blog/2023/05/02/zibo-tourism/"/>
      <url>/angrychow-blog/2023/05/02/zibo-tourism/</url>
      
        <content type="html"><![CDATA[<h2 id="是谁让你去淄博吃烧烤的？"><a href="#是谁让你去淄博吃烧烤的？" class="headerlink" title="是谁让你去淄博吃烧烤的？"></a>是谁让你去淄博吃烧烤的？</h2><p>你打开手机，习惯性的点开了抖音，开始刷起短视频。不知为何，这几天你总是刷到有关淄博烧烤的内容。短视频里，烤串上晶莹的油脂随着炭火的高温融化开来，似乎正隔着屏幕挑动着你的味蕾；网红们将账单怼到镜头前，让你惊呼原来吃一顿烧烤竟然只用花这点钱。你又想起即将到来的五一节——择日不如撞日，干脆五一节去淄博吃烧烤吧。</p><p>很显然，淄博烧烤的爆红并不是偶然，而是有关部门联合短视频平台（抖音、快手等）反复营销后带来的必然的结果。从薛之谦在淄博吃烧烤，到哔哩哔哩策划的《人生一串》纪录片拍摄淄博烧烤，再到抖音众网红开始集中在短视频平台上发布淄博烧烤的爆款视频，都是这个营销策略的一部分。</p><h3 id="互联网公司的业务扩张：政府文旅行业解决方案"><a href="#互联网公司的业务扩张：政府文旅行业解决方案" class="headerlink" title="互联网公司的业务扩张：政府文旅行业解决方案"></a>互联网公司的业务扩张：政府文旅行业解决方案</h3><p>随着我国新冠疫情管控政策的逐步放开，各地的出行政策也渐渐开始调整回疫情开始前的模式，我们也将找回“失去的旅行”。春江水暖鸭先知，资本家们对政策的变动最为敏感。旅游业复苏在即，字节跳动也想要在旅游业的复苏中分一杯羹。字节跳动如何从旅游业中取得利润？这首先要从这家公司推出的“火山引擎”说起。</p><span id="more"></span><p>与阿里云的 PaaS 模式（PaaS是 Platform as a Service 的缩写，是指平台即服务。 把服务器平台作为一种服务提供的商业模式，提供的是“运行环境”的一整套服务）所不同的是，字节跳动的火山引擎云平台提供的是 SaaS 服务（SaaS 是Software as a Service ，软件即服务的简称，提供的是一整套软件运营服务）。换句话说：</p><ul><li>阿里云卖给你的是软件的运行环境，甲方还是需要雇佣产品经理分析需求、雇佣程序员写业务代码、雇佣新媒体成员进行宣发；乙方仅提供软件的运行维护（Ops）。</li><li>字节跳动的火山引擎野心很大，火山引擎卖给甲方一整套的“解决方案”——从需求分析到软件开发到数字化运营增长、用户转化，火山引擎给你包圆了。</li></ul><p>2023 年 2 月，火山引擎数字文旅解决方案和产品架构师潘倩近期在“走进字节跳动，火山引擎文旅高层私享会”上，针对 40 余家境外旅游局、国内外航空公司、国际邮轮、国内旅游集团和涉旅企业，进行了《后疫情时代文旅新增长、新营销》的主题演讲，分享了火山引擎对于“旅游行业新变革，重建更美好境内外游”的经验和思路——这足以见得火山引擎“向官家卖产品”的野心。而在他们架构师所提供的解决方案中，最值得我们注意的有以下几条：</p><ul><li>景区内容制作：解决方案包括对短视频（vlog）脚本测或和拍摄等内容的制作，<strong>助力景区提升线上线下影响力</strong>——换句话说，<strong>这就是字节跳动帮你在短视频平台上制造爆款，快速吸引流量</strong>。</li><li>景区治理：进行景区数字化、智能化升级，打造景区特色，保障景区安全——换句话说，这就是字节跳动火山引擎的产品经理帮你分析景区的特色，挖掘景区的特色，<strong>制造出迎合消费者的消费场景</strong>。</li></ul><p>淄博烧烤的爆火，离不开像是字节跳动火山引擎这样的“解决方案团队”的帮助。其实，“直播带货”的套路也并不新鲜，“短视频平台制造火爆旅游城市”的套路在过去几年也被前人探索过了。淄博烧烤的爆火的意义在于：一个并不以文旅行业见长的地级市，只要借由“专业解决方案团队”的炒作，也能在网上“兴风作浪”，博得眼球。<strong>这从中折射出的是互联网营销技术的炉火纯青——只要平台朝着哪里曝光，哪里就能获得充足的流量。抖音等短视频平台的影响力，经由“淄博烧烤”一役，已经证明达到了至臻之境。</strong></p><p>短视频平台似乎有着一种魔力：只要你愿意同互联网公司进行交易，那么你家的产品就会在接下来的几个月中得到巨量的曝光，无数的人就愿意去光顾你的店铺……这究竟是怎么做到的？要探究这个问题的答案，我们就要从短视频平台的主力内容运营维护者 —— MCN 公司中寻找答案。</p><h3 id="网红们的适者生存原则：短视频平台常青的秘诀"><a href="#网红们的适者生存原则：短视频平台常青的秘诀" class="headerlink" title="网红们的适者生存原则：短视频平台常青的秘诀"></a>网红们的适者生存原则：短视频平台常青的秘诀</h3><p>MCN 公司（Multi-Channel Network，简称 MCN）是指专门为网络视频创作者和内容提供商提供管理、推广、营销、版权维护等服务的公司。MCN公司会与各大视频网站如 抖音、快手、Bilibili 等平台进行合作，帮助其所管理的创作者或内容提供商获得更多的曝光、流量和收益。经过多年的实践，MCN 公司已经探索出了短视频账号的生命周期，可以分为启动、爆发、转化三个阶段。</p><ul><li>启动：积累粉丝数量。账号开始运营的第一个阶段是启动期，在这个阶段，短视频创作者通过发布高质量短视频不断积累粉丝数量。</li><li>爆发：获得广告价值。账号运营到一定阶段后，制造爆款短视频短时间迅速吸纳大量粉丝，构造粉丝池。粉丝数量与单条广告的价格呈正相关关系，爆发阶段积攒的大量粉丝将为短视频账号提供广告议价权。</li><li>转化：实现广告收入。短视频平台账号在内容创作中巧妙地植入广告，获取收益。</li></ul><p>短视频平台的运营者有着相当大的内容创作的压力。在抖音等短视频平台中，即使是优秀的内容创作者，账号的粉丝增长也不是随普通作品而增加的，由于抖音平台的算法影响，只有好的作品才能快速带来粉丝扩展影响力和收益。短视频平台的算法鼓励新人挑战老人，老的短视频创作者们的地位并不安全；而新人只要能够创造出足够优质的内容也可以获得巨量的关注。换言之，短视频平台有着极强的“新陈代谢机制”——能者居于上位，老的内容创作者过去的业绩并不能为其构建出新的内容创作者所不能逾越的护城河。</p><p>在过去的文章中，我曾提到互联网公司是偏好“增量”的，此处仍然适用这个道理。<strong>如果一个短视频账号还有扩张的潜力，他能够吸引更多粉丝、带来增量，那么这个短视频账号他就会被互联网公司看好；但如果一个短视频账号已经不能再贡献更多的优质内容、不能吸引更多的粉丝，那么这个短视频账号就会被互联网公司所抛弃。</strong>互联网公司总是有让自己不断扩张的趋势——这是股东、投资者逐利、希望看到有更多的利润涌入的心理所导致的。从根本上来说，相比于“存量”，互联网公司更看重“增量”——一个产品——在这里，是短视频账号的增长的潜力。</p><p>这就是短视频平台常青的秘诀。并不是短视频平台的内容创作者总是那么活力四射，总是能够产出优质内容，而是因为不能产出优质内容的内容创作者会被快速的淘汰，被用户们快速的抛弃——无论他们之前做得有多好。</p><p>互联网公司将世界最美好的一面展现给他的用户们看，所以我们总是可以在 B 站上刷到充满活力的年轻人们四处探险的 vlog，我们总是可以在小红书上刷到精致的中产阶级的美好生活，我们总是可以在抖音上刷到令人发笑的有趣短视频，我们总是可以在知乎上看到引人入胜的文章。与此同时，互联网公司将这个世界最残酷的一面 —— 物竞天择适者生存的法则展现给了内容创作者，他们必须不断鞭策自己，创作优质内容，才能不被这个信息社会所抛弃。</p><h3 id="淄博烧烤的惊险一跃：市政府动员式的市场调度"><a href="#淄博烧烤的惊险一跃：市政府动员式的市场调度" class="headerlink" title="淄博烧烤的惊险一跃：市政府动员式的市场调度"></a>淄博烧烤的惊险一跃：市政府动员式的市场调度</h3><p>让我们回到淄博烧烤的话题——打铁还需自身硬，淄博烧烤确实便宜分量足。如果淄博烧烤的质量不够高，那么短视频平台给到的巨量流量也只会引来一地鸡毛。然而稍有经济学常识的人就知道，需求越盛，价格越高——淄博烧烤怎么做到人流量这么大，商家还是不涨价的？这就要从另一端——淄博市政府说起。</p><p>马克思在《资本论》中写到：“商品到货币是一次惊险的跳跃。如果掉下去，那么摔碎的不仅是商品，而是商品的所有者”。淄博烧烤自然也跳脱不了这一逻辑：聚光灯之下，淄博烧烤是否能够达到如消费者所期望的那样的质量？淄博烧烤如何能在如此大的人流量之下依然保持“物美价廉”？</p><p>淄博市政府用了非常简单的方法来保证这一点：利用“看得见的手”——也就是政府的强制力来保障价格的低廉。淄博市市场监督管理局曾发布通知称，该市在 2023 年五一假期前后对宾馆酒店客房价格实行涨价幅度控制措施。按3月各类型客房平均成交价格计算，上浮超过 50% 的，按哄抬价格行为予以查处。该市的市场监督管理局甚至连摊贩卖的饼的价格都要限制——小饼卖 3 元，大饼卖 5 元，不允许涨价。</p><p>淄博市政府限价的策略显然可以给游客留下好的影响，似乎有利于当地旅游市场的长远发展。作为处于聚光灯中的城市，这种限价策略很可能是有利于淄博旅游市场长远利益的，毫无疑问这是很好的市场营销策略。</p><p>但是限价策略有着结构性的问题。一个地区的经济发展有赖于无数市场主体的经营。五一劳动节期间客流高峰入境，商家们自然想在旅游旺季获取更多的利润——然而限价令之下，他们只能按照原先的低价进行运营，丢失原本可以到手的利润。<strong>淄博市政府的这一波操作，其代价其实是具体的商家在承担。政府请客、商家买单的模式，是否存在公平性问题?为了淄博的长远利益，这些商家牺牲了自己的短期利益，是否应该得到补偿？</strong></p><p>限价策略也是对市场经济理念的挑战。市场经济一个很重要的原则，就是相信商户们的自己的决策。一个地方的经济发展，是无数的具体的小摊小贩经营导致的。这不是说不要政府宏观的调控，而是说，<strong>不要搞错了次序，认为商家都唯利是图，是市政府的决策在创造财富，真正创造财富的永远是一线经营的劳动者们。</strong>正确的市场观念，才是保证经济持续发展的根本，维护市场经济秩序，才是最长期的利益。</p><h3 id="淄博烧烤的“内里”：地级市的挣扎"><a href="#淄博烧烤的“内里”：地级市的挣扎" class="headerlink" title="淄博烧烤的“内里”：地级市的挣扎"></a>淄博烧烤的“内里”：地级市的挣扎</h3><p>淄博烧烤的“秘传心法”在于短视频平台的病毒式宣传与市政府的动员式经济调度，这两套组合拳让淄博烧烤在全中国面前赚足了吆喝，也让淄博市实打实的实现了经济的增长。然而限价策略可以限一时而不能限一世，淄博烧烤的热度终会散去，低价烧烤也无法构成淄博文旅业的核心竞争力，很难说淄博的文旅业有持续增长的能力。那为什么淄博市政府仍然决心注入这支名为“淄博烧烤”的强心针？宏观数据也许会给我们带来一些答案。</p><p>过去的一年多时间里，中国的货币政策处于相当宽松的状态。2022 年中国的广义货币 M2 同比增长了 11.8%，然而 GDP 增速却只有 3%，货币宽松（简单来说，钞票发行越多也就是货币政策月宽松）的程度可见一斑。但是，我国的物价不仅没有飙升，反而有下降的趋势——三月份的 CPI（物价指数）同比涨幅甚至不到 1%，相较二月份环比下降。大量的货币供应反而导致物价下行——这一现象叫做通货紧缩——背后的原因在于<strong>市场需求的不足</strong>，这也是当今中国经济最大的挑战所在。</p><p>通货紧缩通常意味着经济疲软。以日本为例，日本央行释放流动性（换句话来说，给钱）给各企业后，各企业的并不用来扩大投资，而是用来偿还债务。各个家庭收到工资后，第一反应并不是拿钱消费，他们工资的大头拿去偿还贷款了，剩下的钱拿去银行存起来了——总之，企业和个人都不愿意把手上的钱花出去。如此一来，就算央行释放再多的流动性（也就是印钱），也很难让市场活动起来，也就造成了通货紧缩。</p><p>疫情之后，中国的外贸正缓慢复苏——但速度仍不尽人意。各个工业城市急需除了传统第一、第二产业以外的别的增长点。对于淄博来说，他们走出了小地级市的第三产业文旅服务开拓的第一步。如何创造更多的消费增长点，让居民们走出家门去消费？如何拉动“内循环”，拉动居民消费意愿？这是中国这片土地上所有的市长们都在苦恼着的问题。</p><p>“民生是人民幸福之基，社会和谐之本。”</p><p>参考内容：</p><ul><li>字节跳动，火山引擎白皮书</li><li>李嘉泽，短视频平台 MCN 化运营下的盈利模式：基于“抖音”平台的案例</li><li>张菁菁，青年女性网络“种草”传播研究</li><li>南方都市报，淄博被限价的酒店应当得到补偿</li><li>谢九，中国经济要通缩了吗？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短视频平台是怎样送你去淄博吃烧烤的？</title>
      <link href="/angrychow-blog/2023/05/02/zibo-tourism-censored-edition/"/>
      <url>/angrychow-blog/2023/05/02/zibo-tourism-censored-edition/</url>
      
        <content type="html"><![CDATA[<h2 id="短视频平台是怎样送你去淄博吃烧烤的？"><a href="#短视频平台是怎样送你去淄博吃烧烤的？" class="headerlink" title="短视频平台是怎样送你去淄博吃烧烤的？"></a>短视频平台是怎样送你去淄博吃烧烤的？</h2><p>你打开手机，习惯性的点开了抖音，开始刷起短视频。不知为何，这几天你总是刷到有关淄博烧烤的内容。短视频里，烤串上晶莹的油脂随着炭火的高温融化开来，似乎正隔着屏幕挑动着你的味蕾；网红们将账单怼到镜头前，让你惊呼原来吃一顿烧烤竟然只用花这点钱。你又想起即将到来的五一节——择日不如撞日，干脆五一节去淄博吃烧烤吧。</p><p>很显然，淄博烧烤的爆红并不是偶然，而是有关部门联合短视频平台（抖音、快手等）反复营销后带来的必然的结果。从薛之谦在淄博吃烧烤，到哔哩哔哩策划的《人生一串》纪录片拍摄淄博烧烤，再到抖音众网红开始集中在短视频平台上发布淄博烧烤的爆款视频，都是这个营销策略的一部分。</p><h3 id="互联网公司的业务扩张：政府文旅行业解决方案"><a href="#互联网公司的业务扩张：政府文旅行业解决方案" class="headerlink" title="互联网公司的业务扩张：政府文旅行业解决方案"></a>互联网公司的业务扩张：政府文旅行业解决方案</h3><p>随着我国新冠疫情管控政策的逐步放开，各地的出行政策也渐渐开始调整回疫情开始前的模式，我们也将找回“失去的旅行”。春江水暖鸭先知，资本家们对政策的变动最为敏感。旅游业复苏在即，字节跳动也想要在旅游业的复苏中分一杯羹。字节跳动如何从旅游业中取得利润？这首先要从这家公司推出的“火山引擎”说起。</p><span id="more"></span><p>与阿里云的 PaaS 模式（PaaS是 Platform as a Service 的缩写，是指平台即服务。 把服务器平台作为一种服务提供的商业模式，提供的是“运行环境”的一整套服务）所不同的是，字节跳动的火山引擎云平台提供的是 SaaS 服务（SaaS 是Software as a Service ，软件即服务的简称，提供的是一整套软件运营服务）。换句话说：</p><ul><li>阿里云卖给你的是软件的运行环境，甲方还是需要雇佣产品经理分析需求、雇佣程序员写业务代码、雇佣新媒体成员进行宣发；乙方仅提供软件的运行维护（Ops）。</li><li>字节跳动的火山引擎野心很大，火山引擎卖给甲方一整套的“解决方案”——从需求分析到软件开发到数字化运营增长、用户转化，火山引擎给你包圆了。</li></ul><p>2023 年 2 月，火山引擎数字文旅解决方案和产品架构师潘倩近期在“走进字节跳动，火山引擎文旅高层私享会”上，针对 40 余家境外旅游局、国内外航空公司、国际邮轮、国内旅游集团和涉旅企业，进行了《后疫情时代文旅新增长、新营销》的主题演讲，分享了火山引擎对于“旅游行业新变革，重建更美好境内外游”的经验和思路——这足以见得火山引擎“向官家卖产品”的野心。而在他们架构师所提供的解决方案中，最值得我们注意的有以下几条：</p><ul><li>景区内容制作：解决方案包括对短视频（vlog）脚本测或和拍摄等内容的制作，<strong>助力景区提升线上线下影响力</strong>——换句话说，<strong>这就是字节跳动帮你在短视频平台上制造爆款，快速吸引流量</strong>。</li><li>景区治理：进行景区数字化、智能化升级，打造景区特色，保障景区安全——换句话说，这就是字节跳动火山引擎的产品经理帮你分析景区的特色，挖掘景区的特色，<strong>制造出迎合消费者的消费场景</strong>。</li></ul><p>淄博烧烤的爆火，离不开像是字节跳动火山引擎这样的“解决方案团队”的帮助。其实，“直播带货”的套路也并不新鲜，“短视频平台制造火爆旅游城市”的套路在过去几年也被前人探索过了。淄博烧烤的爆火的意义在于：一个并不以文旅行业见长的地级市，只要借由“专业解决方案团队”的炒作，也能在网上“兴风作浪”，博得眼球。<strong>这从中折射出的是互联网营销技术的炉火纯青——只要平台朝着哪里曝光，哪里就能获得充足的流量。抖音等短视频平台的影响力，经由“淄博烧烤”一役，已经证明达到了至臻之境。</strong></p><p>短视频平台似乎有着一种魔力：只要你愿意同互联网公司进行交易，那么你家的产品就会在接下来的几个月中得到巨量的曝光，无数的人就愿意去光顾你的店铺……这究竟是怎么做到的？要探究这个问题的答案，我们就要从短视频平台的主力内容运营维护者 —— MCN 公司中寻找答案。</p><h3 id="网红们的适者生存原则：短视频平台常青的秘诀"><a href="#网红们的适者生存原则：短视频平台常青的秘诀" class="headerlink" title="网红们的适者生存原则：短视频平台常青的秘诀"></a>网红们的适者生存原则：短视频平台常青的秘诀</h3><p>MCN 公司（Multi-Channel Network，简称 MCN）是指专门为网络视频创作者和内容提供商提供管理、推广、营销、版权维护等服务的公司。MCN公司会与各大视频网站如 抖音、快手、Bilibili 等平台进行合作，帮助其所管理的创作者或内容提供商获得更多的曝光、流量和收益。经过多年的实践，MCN 公司已经探索出了短视频账号的生命周期，可以分为启动、爆发、转化三个阶段。</p><ul><li>启动：积累粉丝数量。账号开始运营的第一个阶段是启动期，在这个阶段，短视频创作者通过发布高质量短视频不断积累粉丝数量。</li><li>爆发：获得广告价值。账号运营到一定阶段后，制造爆款短视频短时间迅速吸纳大量粉丝，构造粉丝池。粉丝数量与单条广告的价格呈正相关关系，爆发阶段积攒的大量粉丝将为短视频账号提供广告议价权。</li><li>转化：实现广告收入。短视频平台账号在内容创作中巧妙地植入广告，获取收益。</li></ul><p>短视频平台的运营者有着相当大的内容创作的压力。在抖音等短视频平台中，即使是优秀的内容创作者，账号的粉丝增长也不是随普通作品而增加的，由于抖音平台的算法影响，只有好的作品才能快速带来粉丝扩展影响力和收益。短视频平台的算法鼓励新人挑战老人，老的短视频创作者们的地位并不安全；而新人只要能够创造出足够优质的内容也可以获得巨量的关注。换言之，短视频平台有着极强的“新陈代谢机制”——能者居于上位，老的内容创作者过去的业绩并不能为其构建出新的内容创作者所不能逾越的护城河。</p><p>在过去的文章中，我曾提到互联网公司是偏好“增量”的，此处仍然适用这个道理。<strong>如果一个短视频账号还有扩张的潜力，他能够吸引更多粉丝、带来增量，那么这个短视频账号他就会被互联网公司看好；但如果一个短视频账号已经不能再贡献更多的优质内容、不能吸引更多的粉丝，那么这个短视频账号就会被互联网公司所抛弃。</strong>互联网公司总是有让自己不断扩张的趋势——这是股东、投资者逐利、希望看到有更多的利润涌入的心理所导致的。从根本上来说，相比于“存量”，互联网公司更看重“增量”——一个产品——在这里，是短视频账号的增长的潜力。</p><p>这就是短视频平台常青的秘诀。并不是短视频平台的内容创作者总是那么活力四射，总是能够产出优质内容，而是因为不能产出优质内容的内容创作者会被快速的淘汰，被用户们快速的抛弃——无论他们之前做得有多好。</p><p>互联网公司将世界最美好的一面展现给他的用户们看，所以我们总是可以在 B 站上刷到充满活力的年轻人们四处探险的 vlog，我们总是可以在小红书上刷到精致的中产阶级的美好生活，我们总是可以在抖音上刷到令人发笑的有趣短视频，我们总是可以在知乎上看到引人入胜的文章。与此同时，互联网公司将这个世界最残酷的一面 —— 物竞天择适者生存的法则展现给了内容创作者，他们必须不断鞭策自己，创作优质内容，才能不被这个信息社会所抛弃。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础架构的红海中是否还存在一条坦途</title>
      <link href="/angrychow-blog/2023/04/16/%E6%91%A9%E8%A5%BF%E5%88%86%E6%B5%B7%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A2%E6%B5%B7%E4%B8%AD%E6%98%AF%E5%90%A6%E8%BF%98%E5%AD%98%E5%9C%A8%E4%B8%80%E6%9D%A1%E5%9D%A6%E9%80%94/"/>
      <url>/angrychow-blog/2023/04/16/%E6%91%A9%E8%A5%BF%E5%88%86%E6%B5%B7%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A2%E6%B5%B7%E4%B8%AD%E6%98%AF%E5%90%A6%E8%BF%98%E5%AD%98%E5%9C%A8%E4%B8%80%E6%9D%A1%E5%9D%A6%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p><em>本文内容为与两位学长聚餐时的聊天内容的整合</em></p><h2 id="基础架构的红海中是否还存在一条坦途"><a href="#基础架构的红海中是否还存在一条坦途" class="headerlink" title="基础架构的红海中是否还存在一条坦途"></a>基础架构的红海中是否还存在一条坦途</h2><h3 id="新的数据库范式"><a href="#新的数据库范式" class="headerlink" title="新的数据库范式"></a>新的数据库范式</h3><p>2008 年，Oracle 公司收购了 MySQL 公司。在这一天，也许很多人会认为关系型数据库的技术架构发展历程已经走向了尽头，剩下的都是对现有模型的小修小补。但是互联网公司的快速崛起使得传统的单节点关系型数据库显得有些过时。从数据库层面来看，互联网公司的业务相较于其他行业的业务有以下两个特点：</p><ul><li>互联网公司每时每刻都在接收和处理大量的数据，他们要提供的服务需要分布式来减轻单台主机的负载，提高可用性。</li><li>互联网公司对于每天所产生的大量用户数据非常感兴趣——他们希望能够在线分析用户数据（跑模型，分析用户偏好等），然后将分析的结果用于优化推送结果等。</li></ul><span id="more"></span><p>在这基础上，开发者们大致分了两类数据库：</p><ul><li><p>在线处理型数据库（Online Transaction Processing，OLTP）<br>OLTP 数据库一般要处理大量的增删查改操作。因此，OLTP 数据库需要支持高并发、低延迟的事务处理，并且需要让数据库高度可用（提高系统的可用性和容错性，将事务分散到多个节点上进行计算，即使某个节点出现故障，整个系统仍然可以正常运行）。为达到这种要求，OLTP 数据库需要支持集群、分布式计算，以实现负载均衡，实现高可用性。</p></li><li><p>在线分析型数据库（Online Analytical Processing，OLAP）<br>OLAP 数据库主要用于多维数据的分析，这类数据库所要实现的最主要的功能是进行对大规模数据的快速分析与查询。从具体业务的角度来讲，OLAP 数据库通常支持复杂的查询和分析操作，例如数据透视表、多维分析、数据切片和切块、数据挖掘等。</p></li></ul><p>目前而言，一些互联网公司现在的架构就是让在线处理型数据库挡在在线分析型数据库前面。在线处理型数据库用于处理业务，然后公司内部需要对数据进行分析的时候，处理型数据库导出数据到分析型数据库，公司里的数据分析师再根据分析型数据库去做分析。</p><p>传统的数据库对以上两点的支持相当的差。以 <code>MySQL</code> 为例，它本身是单节点的数据库——所有的数据都被持久化在单台主机之上。虽然开发者们可以通过数据分片、主从复制等方式实现分布式存储与计算，但是这种方式显著的增加了系统的复杂性。使用 MySQL 进行数据分析也非常不理想。复杂的分析需求往往无法用 SQL 表达，同时数据分析通常需要对多维数据进行操作，使用 SQL 查询会导致大量的联合操作，使得分析效率低下。</p><p>业务需求的急剧变化使得数据库行业焕发第二春。2015 年时，中国的数据库公司只有约 15 家，八年后，这个数字翻了两番。</p><h3 id="大厂为什么乐于开源基础架构：PaaS-业务"><a href="#大厂为什么乐于开源基础架构：PaaS-业务" class="headerlink" title="大厂为什么乐于开源基础架构：PaaS 业务"></a>大厂为什么乐于开源基础架构：PaaS 业务</h3><p>目前，有很多公司——无论是初创公司还是大厂——都在进行基于新的数据库模型的基础架构开发。国内目前比较火的开源分布式数据库有 <code>TiDB</code>（PingCAP 开发，中国数据库领域的独角兽公司），OceanBase（阿里系资本主导的的数据库公司，脱胎于支付宝的数据库架构）等。然而对于大厂而言，做数据库开源、扩大技术影响力不是他们的目的所在，他们的最终目的是基于他们的数据库架构，出售 PaaS（Platform as a Service）作为解决方案。</p><p>PaaS 与一般的服务器租赁服务不同。PaaS 服务提供商为开发者提供的不仅仅是服务器租赁服务，还有一系列计算、存储、数据库、消息队列、缓存、日志分析等软件服务。在服务商提供的平台上，开发者可以仅仅通过写几个配置文件来部署应用程序，而不需要关心底层的硬件、操作系统、中间件和其他基础设施等细节。当然，提供 PaaS 的前提是，服务的提供商需要建立一整套围绕着这些系统中间件的“生态环境”。</p><p>总的来说，阿里云所提供的 PaaS 服务想要提供的是一整套运维服务。使用 PaaS 服务的开发人员无需关注服务器的基础设施，无需构建应用程序，他们只需要编写和测试自己的应用程序就可以上线服务。对于阿里而言，基础架构对内可以提高企业内应用开发迭代的效率，有利于公司的技术积累；对外还可以将这些基础架构打包成云服务卖出去，实现盈利。</p><p>大厂的基础架构开源能够走得长久吗？PingCAP创始人刘奇说：带着KPI去做开源，大概率是搞不成的。</p><p>在一段访谈中，刘奇说：</p><p><em>如果开源是战略，不好意思，所有其他东西通通为开源让路，但是如果是KPI，不好意思，开源一边站。随着时间的积累，一天，两天，一年，两年，长时间下来差别就很大了。所以外面有一个说法挺有意思，说PingCAP是真开源，真开放。大家可能也听过另外一种开源，叫KPI开源，KPI开放。</em></p><p><em>到底什么是开源，开源的本质到底是什么。很多的理解认为开源就是把代码往那一放（Source Open不等于Open Source），就觉得这就是开源，实际上来说，这个代码只是一个载体，今天可以看到我们整个运营的体系，整个开发的体系完全建立在开源上面。</em></p><p><em>举个例子，比如刚才我们提到了一些别的开源项目，这些开源项目一天有多少个PR在合并，一天又多少个讨论在上面进行，它只是一个代码同步工具，还是说它真的是一个代码的协作平台，是一个人和人之间的连接和协作平台，我觉得这个是它非常本质的一个差别，就是我们到底把开源放在什么样的位置。</em></p><p><em>我们也知道业界里面有一些厂商常常说：“我们第一次开源了，我们又一次开源了，这一次开源我们是认真的”。</em></p><h3 id="认真做数据库的公司能够活下去吗"><a href="#认真做数据库的公司能够活下去吗" class="headerlink" title="认真做数据库的公司能够活下去吗"></a>认真做数据库的公司能够活下去吗</h3><p>对于大厂而言，他们有盈余时，可以“供养”基础架构工程师们进行开发，让他们为公司的业务开发打好牢固的基础设施基础；对于“特供”企业而言，他们不需要有独角兽级别的技术就能吃的盆满钵满。但是对于 PingCAP 这类“为数据库和开源而生”的公司而言，他们很难在中国找到一条变现的路径。五轮融资之后，PingCAP 仍然没有找到合适的商业化之路，现目前正在进行裁员。</p><p>这里我们引用一条关于对 PingCAP 裁员消息的评论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：匿名用户</span><br><span class="line">链接：https://www.zhihu.com/question/590345523/answer/2942682182</span><br><span class="line">来源：知乎</span><br></pre></td></tr></table></figure><p><em>利益相关：db从业者。</em></p><p><em>国产数据库的浪潮，造就了很多类似第一代互联网的知识英雄的光鲜人物，这些人和他背后的公司更在乎技术、学术，光环拉满，但是现实是非常沉重的。数据库首先是商业软件，惋惜pingcap裁员的同时，不如想想，在中国，什么样的企业会去花钱买TiDB？</em></p><p><em>互联网大厂？有听说用的，但是不多；中厂？确实有一些；小厂？买不起企业版，顶多用开源的。这些加起来份额有多少？政府央国企？这些可不管 TiDB 的技术PR多么诱人，他们首先就看，你这个数据库满足国产化要求吗，在信创目录里吗，用这个XX局&#x2F;处&#x2F;总能同意吗？不能就给你pass了。那在这种现实下， TiDB 能怎么办呢？有人一直在抱怨 TiDB PR多，吹牛多，从号称 Spanner 到 HTAP 再到 Serverless，假如 TiDB 能像XX之类的数据库拿政府单子拿到手软，他还用得着各种技术PR忽悠投资人么。。。</em></p><p><em>现在国内最大的盘子就是国产化，一些DB从业者看不上的厂商，拿了无数你们公司会眼热的订单，而你们所谓亮闪闪技术牛逼炸的公司连入场投标资格都没有。这个就是现实。</em></p><p>“为什么很多牛逼的开源软件来自欧洲，因为欧洲的失业保障平均每个月六七千块欧元。为什么<code>core.js</code>停更？因为开源作者在俄罗斯，找不到工作不说，骑摩托撞了人还得坐牢。如果你想挣钱，你必须时刻紧盯业务，你必须了解业务，这样你才能挣钱。”这是我的学长在谈到中间件开发时的感叹。</p><p>国产软件自研，任重而道远。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻求增量：互联网公司的本能</title>
      <link href="/angrychow-blog/2023/04/08/%E5%AF%BB%E6%B1%82%E5%A2%9E%E9%87%8F%EF%BC%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E6%9C%AC%E8%83%BD/"/>
      <url>/angrychow-blog/2023/04/08/%E5%AF%BB%E6%B1%82%E5%A2%9E%E9%87%8F%EF%BC%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E6%9C%AC%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="寻求增量：互联网公司的本能"><a href="#寻求增量：互联网公司的本能" class="headerlink" title="寻求增量：互联网公司的本能"></a>寻求增量：互联网公司的本能</h2><p><strong>对于互联网公司来说，不进则退，他们总是有让自己不断扩张的趋势——这是股东、投资者逐利、希望看到公司市值上升的心理所导致的。</strong></p><p><em>笔者按：笔者同一位正在一家名为“八比特跳动”的互联网公司上班的学长聚餐，聚餐时聊到了以下内容。</em></p><p>笔者：学长，最近“八比特跳动”的校招情况如何？我听说最近互联网公司的行情都非常不好，Head Count（职位空缺）也非常的少。具体到“八比特跳动”是什么情况呢？</p><p>学长：你错啦，“八比特跳动”去年营收了 800 多亿美元，总的来说“八比特跳动”这家公司目前的经营状况还是非常好。目前公司确实裁人裁不少，但是首先裁员是看部门的，你比如最近飞书就裁员裁的非常狠。你知道吗？飞书这一个产品，一共有八千个人在做，这是不是有点过分了。整个推特一共也就八千来人吧，飞书这个项目很明显有人员冗余。</p><p>笔者：我听说飞书最近在做商业化，我自己在使用飞书的时候也有这样的体验，原先免费的功能现在付费了。这有助于缓解飞书裁员的现状吗？</p><span id="more"></span><p>学长：不太现实。首先第一点，飞书的定位其实是有问题的，你想想飞书是让员工爽了，但是买的人是谁？买的人是老板啊！飞书自己的 slogan 就是“先进团队，先用飞书”，自我定位就是一个协作工具，而不是一个管理工具。飞书对于老板的吸引力实在是很有限。而且，这类软件还有一个通用问题：数据安全和定制化。你看像是汽车、金融、一般制造业……这么多行业，每个行业要做的解决方案都不一样，你可以给每一个行业都去做一个解决方案，然后安排专人去做对接，这么做的话，你的人效根本上不去。</p><p>学长：而且飞书有整整八千人啊，你想想，譬如有个两百万的单子，大概也就够几个员工吃一年，你说销售的压力大不大？更别说给公司赚钱了。归根到底，飞书的人效，ROI（投资回报率）太低，裁员是无可避免的事。研发（开发者）的情况稍微好点，你的小组被解散了之后你还有机会被活水（指派到其他部门），对于产品这些角色来说，他们被直接裁员的概率更大。不过对于研发来说，被活水到别的部门也是会对职业前景造成很多影响的。</p><p>笔者：那比如一个产品做不下去了，企业怎么评定要裁员哪些人，对于我们这些开发者来说，互联网怎么去认定一个研发的绩效呢？</p><p>学长：其实，你作为一个研发干的好不好，会不会被裁员，主要还是取决于你的 leader 怎么想。“八比特跳动”里面的团队的 leader 往往是研发，平常 leader 就会给你指派任务，然后他们在绩效评定的时候有最终的话语权——其实对于研发来说他们的绩效评定并没有特别客观的标准，主要还是看你的 leader 觉得你靠不靠谱。其实你看，在互联网大厂里面，一个研发他自己的前途，除了和他本人的能力以外还和自己在做的产品的前途息息相关。譬如你进了一个增量特别高的产品里面做研发，可能你就是按部就班的把所有的开发任务都做完，但是你的职业生涯跟着这个产品一起成长，最后这个产品有前景、增长特别快，给公司带来了越来越多的利润，那么你就可以在这个公司成长起来，获得很多利益。</p><p>学长：相反的，如果一个产品它本身没有办法带来增量，那么即便你一个研发做的再好，你也很难在公司里成长出来。我们还是拿飞书举例子，飞书这个项目从研发的角度来看，他们使用的技术栈是非常激进的。而且，飞书的各项功能确实做的也非常不错。但是这有什么用？飞书这个产品卖不出去，那么这些个研发也很难获得成长。<strong>所以，作为研发，跟对正确的产品是非常重要的。</strong>可能你想说“没有功劳，也有苦劳”，我们研发写了这么多代码，干了这么多活儿，这些个代码摆在这里。但是股东、投资者是不会乐意看到这种情况的，他们绝对不希望公司的管理者给没有用的产品烧钱。</p><p>笔者：股东、投资者是希望互联网公司一直产出利润吗？</p><p>学长：不准确。<strong>股东、投资者可不指望着吃公司的分红，他们最看重的是他们所投资的公司的市值，他们希望看到的是他们手上的股票变得越来越值钱，他们希望看到的是互联网公司的不断扩张。</strong> 如果一个产品他还有扩张的潜力，他能够增加市值、带来增量，那么这个产品他就会被互联网公司看好；但如果一个产品已经变得死气沉沉、不能贡献出更多的增量，那么这个业务就容易发生萎缩。况且，你看现在的技术也在不断迭代，完成一个业务所需要的人会变得越来越少。<strong>对于互联网公司来说，不进则退，他们总是有让自己不断扩张的趋势——这是股东、投资者逐利、希望看到公司市值上升的心理所导致的。</strong>从根本上来说，相比于“存量”，互联网公司更看重“增量”——一个产品增长的潜力。</p><p>学长：<strong>我觉得，我们这些研发不仅要不断地打磨自己的技术，更要抬起头来看看远方的路，看看自己在做的东西是否有前景。</strong></p><p>笔者：受教了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我对应用层开发程序员的未来感到悲观</title>
      <link href="/angrychow-blog/2023/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9C%AA%E6%9D%A5%E6%84%9F%E5%88%B0%E6%82%B2%E8%A7%82/"/>
      <url>/angrychow-blog/2023/03/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9C%AA%E6%9D%A5%E6%84%9F%E5%88%B0%E6%82%B2%E8%A7%82/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我对应用层开发程序员的未来感到悲观"><a href="#为什么我对应用层开发程序员的未来感到悲观" class="headerlink" title="为什么我对应用层开发程序员的未来感到悲观"></a>为什么我对应用层开发程序员的未来感到悲观</h2><h3 id="互联网企业的“去肥增瘦”"><a href="#互联网企业的“去肥增瘦”" class="headerlink" title="互联网企业的“去肥增瘦”"></a>互联网企业的“去肥增瘦”</h3><p>关注就业情况的应届毕业生们和大厂的员工们一定能够感到 2023 年互联网就业市场的萧条。以字节跳动为例，其于 2022 年的下半年就提出了“去肥增瘦”的口号。所谓“去肥增瘦”，就是企业管理中降本增效的同义词。</p><p>“互联网公司”是一个诞生仅十余年的概念，但是在各色“职业经理人”的出色规划之下，各大互联网公司已经几乎快要将整个市场瓜分干净了。再加之目前经济状况下行，互联网公司连裁员都来不及，新添的业务也肯定优先考虑来自其他被解散的业务组的“活水”，应届大学生找到工作，只能是难上加难。</p><span id="more"></span><p>更要命的是，许多行业龙头运营到现在，仍然处于亏损的状态。根据 2022 年的公司财报，美团、滴滴、快手、哔哩哔哩等公司（以上公司均是该领域的龙头企业）在当年均亏损了上百亿。一般认为互联网公司初期的时候需要大量“烧钱”以迅速扩张占领市场，等公司发展的足够庞大、市场占有率足够高的时候便能实现盈利。但是美团等公司的财报表明了一个事实：一家互联网公司即便已经“占领”了市场，这也不意味着它就能完成盈利。</p><p>一家公司不能一直依赖投资银行的输血活下去。但现实是，许多互联网公司到目前都没有实现扭亏为盈。我周围的很多热衷于股票交易的朋友喜欢嘲笑茅台的“酱香科技”：背后的一层含义是茅台公司的市值如此之高，完全是因为投资经理人们“抱团”、炒高茅台的股票价格，营造虚构的市值繁荣。但是，至少茅台迄今为止仍然在盈利，中国大大小小的饭局上总是有茅台酒的出现。然而中国的一些龙头互联网公司迄今为止仍然不能实现盈利，与此同时互联网行业的寒冬却又接踵而至。换句话说 —— 互联网公司的泡沫（或者说“水分”）太多了。</p><p>覆巢之下，焉有完卵。作为互联网公司的流水线工人，应用层开发的程序员们在互联网行业的寒冬之下是很难有好日子过的。</p><h3 id="技术奇点：AI-会大大降低应用层开发的门栏"><a href="#技术奇点：AI-会大大降低应用层开发的门栏" class="headerlink" title="技术奇点：AI 会大大降低应用层开发的门栏"></a>技术奇点：AI 会大大降低应用层开发的门栏</h3><p>软件技术分两类，第一类软件技术优化成品，第二类技术减轻程序员的心智负担。稍有关注 AI 技术前沿的朋友们都会知道 copilot 和 ChatGPT 这两项技术（这都是微软系的产品）。如果你安装了 copilot 插件，那么你只需要在编辑器中输入注释，copilot 就会按照注释为你补全你想要的代码。而ChatGPT 现目前还没有达到“用户输入需求，ChatGPT 生成一大段满足用户需求的可以运行的代码”的能力，但是经过笔者自己的体验，拿 ChatGPT 问问相关技术的 API 接口的使用方式已然是绰绰有余。</p><p>如果说前些年的技术 —— 例如 JAVA 的 Spring 框架，React 的函数式编程范式还需要应用层开发的程序员学习相关概念和熟悉代码编写的基本逻辑，那么 AI 的发展将很可能会让应用层程序员免去大量的业务代码的编写时间（大多数应用层程序员做的其实就是调用接口而已）。</p><p>重复劳动的自动化的结果就是行业需求快速萎缩。如果原先需要五个小时才能完成的需求现在在 AI 的辅助下只需要一个小时就能完成的话，那么五个人的业务组就会被“优化”为一个人。毕竟，只需要一个人就可以完成所有的工作。</p><p>况且我在上一节提到，互联网公司现在日子很不好过，需要节省成本。又很不恰好的是 AI 技术“赋能”程序员，提高了个体应用层开发程序员的开发效率。那么此时，原先是业务线的“瘦肉”的应用层开发程序员就会摇身一变成为“肥肉”，被互联网公司用切五花肉的大菜刀迅速去除，哈哈！</p><h3 id="未来：应用层开发程序员会计化"><a href="#未来：应用层开发程序员会计化" class="headerlink" title="未来：应用层开发程序员会计化"></a>未来：应用层开发程序员会计化</h3><p>笔者的父母就是金融从业者，我也从他们口中听到了许多关于会计行业发展的故事。恰巧，前几天我在知乎上看到一篇回答，以飨读者：</p><p>作者：郑天玑<br>链接：<a href="https://www.zhihu.com/question/569408745/answer/2917813818">https://www.zhihu.com/question/569408745/answer/2917813818</a><br>来源：知乎（有删节）</p><p>“现在画师的挣扎就像信息化前夜的老财（<em>文中老财均指代财会</em>）。当年老财也很自信认为自己不会被淘汰，觉得人为会计判断是艺术，多么牛逼，然而时代大浪滚滚，现实中所谓的淘汰往往不是直接行为，而大多数以业务模块化流水线化、岗位缩减等间接形式表现。</p><p>比如以前多成立一家公司就要多配备一个出纳一个会计，而财税整体信息化后可以集中管理，5个人可以管理100家，记账公司疯狂内卷甚至一个人管理50家，原本一家40亿规模的大型制造企业需要20人以上老财，现在已经可以压倒10人不到，甚至部门业务开始直接不招人采取外包模式，你说这是直接淘汰吗？</p><p>同比现在的业务量信息化前后老财需求减少了之前70%，而老财学生年年毕业年年增长涌入市场，<strong>如果不是靠经济整体高速增长往上走，根本消化不了那么多就业人群，经济危机一来整个老财行业薪资会被无限压低</strong>，可以预见的未来是AI会逐渐蚕食这个行业原本所谓的高端市场，到时候从上到下的垂直打击下，老财行业会彻底消亡。</p><p>这就是所有的故事，不要老拿大触来对标自己，你只是市场普通的一员，AI 只要能替换很低层次的商业需求就足够把大部分岗位消灭，市场干涸之时你连成长大触的机会都没有。”</p><p><em>我对应用层开发者的前途的悲观情绪，都凝结在此文中了。</em></p><p>无论前路如何，笔者仍然祝各位开发者们前途无忧，(老婆|老公)孩子热炕头，不会被去肥增瘦，开心过好每一天✌</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opinion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUI 开发中的事件驱动机制</title>
      <link href="/angrychow-blog/2023/01/23/GUI%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/angrychow-blog/2023/01/23/GUI%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="GUI-开发中的事件驱动机制"><a href="#GUI-开发中的事件驱动机制" class="headerlink" title="GUI 开发中的事件驱动机制"></a>GUI 开发中的事件驱动机制</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>很显然，您手头正在使用的计算机允许你同时运行好几个应用程序，这归功于您手头正在使用的计算机的操作系统支持“并发”（concurrency）。多个应用程序被抽象为多个进程，然后由操作系统来调度这多个进程。每个进程会被操作系统分配一个时间片，即每次被 CPU 选中来执行当前进程所用的时间。由于 CPU 的频率太高，进程之间的切换并不会让用户感到卡顿，所以给人一种“几个应用程序同时在运行”的感觉。</p><p>一个进程可以拥有多个线程（Thread），不同的线程完成不同的任务，一个进程中线程之间的调度同样也是分配时间片、切换线程的模式。</p><p>值得强调的是，进程与线程的<strong>调度</strong>是由操作系统进行的。</p><span id="more"></span><ul><li>同步与异步</li></ul><p>进程间存在相互制约的关系。例如，进程 A 的某一个任务需要某一个资源才能继续进行，而这个资源需要进程 B 释放后进程 A 才能使用。那么，这之间就存在进程调度的问题。这里有进程同步与进程异步两种方案：</p><p><img src="https://www.koyeb.com/static/images/blog/sync-vs-async-schema.png" alt="async"></p><p>在进程同步（Synchronous Processing）中，进程 A 等待进程 B 的回应，期间不执行任务。在进程异步(Asynchronous Processing)中，进程 A 在等待进程 B 的过程中仍然在处理任务。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调函数作为另一个函数的<strong>参数</strong>被传递过去。回调函数作为<strong>形式参数</strong>可以被别的函数所调用。</p><p>有时，我们希望在程序中某个耗时任务结束后执行一个函数。以上面的异步进程方案为例，我希望进程 A 在收到来自进程 B 的回应后进行相关的处理。</p><p>例如在 javascript 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(callback,<span class="number">1000</span>);<span class="comment">//it means: call callback after 1000ms</span></span><br></pre></td></tr></table></figure><p>setTimeout 函数在计时器达到 1000ms 后调用 <code>callback</code> 函数。在这里我们可以看到，调用函数的主体并不是应用程序，而是负责底层运作的其他程序。在同步异步编程中，我们常常用到回调函数。</p><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><h3 id="什么是事件驱动"><a href="#什么是事件驱动" class="headerlink" title="什么是事件驱动"></a>什么是事件驱动</h3><p>也许您之前编写的程序的工作流程是这样的：</p><p><strong>打开程序</strong> -&gt; <strong>程序执行</strong> -&gt; <strong>执行完毕，自行退出</strong></p><p>对于一个事件驱动的程序而言，其工作流程是这样的：</p><p><strong>打开程序</strong> -&gt; <strong>程序初始化后等待用户操作</strong> -&gt; <strong>用户操作，执行相应代码，继续等待用户操作</strong> -&gt; <strong>用户退出，程序结束</strong></p><p>我们可以看到，对于一个事件驱动的程序而言，他的程序的执行并不是按照某个既定顺序的。事件驱动的程序面向收到的事件编程：某个事件产生了，应用程序做出相应的回应。</p><h3 id="事件驱动的实例：消息循环"><a href="#事件驱动的实例：消息循环" class="headerlink" title="事件驱动的实例：消息循环"></a>事件驱动的实例：消息循环</h3><p>下面这张图展示了一个事件驱动型系统的事件分发模型。</p><p><img src="https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/event-driven.svg" alt="event_driven"></p><p>具体到 Windows 下的 GUI 开发而言，Event Producers 可以是鼠标点击、键盘按下这样的事件，也可以是定时器事件（到了某一个特定的时间点，产生一个事件）。在 Windows 操作系统中，每一个线程存在一个消息队列，操作系统来维护线程的消息队列，各类事件的分发都由操作系统来执行。在这里，Windows 操作系统担任了 Event Ingestion 的角色。最后，线程在自己的消息队列中通过操作系统接口获得 Windows 操作系统为其提供的 Events，并将其进行处理，担任了 Event Consumers 的角色。</p><p>下面是 Win32 SDK 提供的 <code>GetMessage</code>函数的使用例子，这里的程序代码被真实地使用在 GUI 开发中。（细节被省略了)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(args...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="comment">// 主消息循环:</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">TranslateAccelerator</span>(msg.hwnd, hAccelTable, &amp;msg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">            <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的代码看起来不知所云，我们只需要关心最后几行，也就是“主消息循环”的部分：<code>GetMessage</code>让线程得以从消息队列中获取消息（传递到变量 msg 中，注意到这里是引用传递）。如果获得的是退出的消息，那么<code>GetMessage</code>将会返回 0 让程序退出消息循环。如果没有得到消息，那么<code>GetMessage</code>函数将会<strong>阻塞</strong>当前线程（也就是让当前线程“睡着”），不返回值。</p><p>一个典型的事件驱动的程序，包含一个不断执行循环（在上面这个例子中，就是消息循环），并以一个线程的形式存在，这个循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。接下来是程序处理事件的程序段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  目标: 处理主窗口的消息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  WM_COMMAND  - 处理应用程序菜单</span></span><br><span class="line"><span class="comment">//  WM_PAINT    - 绘制主窗口</span></span><br><span class="line"><span class="comment">//  WM_DESTROY  - 发送退出消息并返回</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> wmId = <span class="built_in">LOWORD</span>(wParam);</span><br><span class="line">            <span class="comment">// 分析菜单选择:</span></span><br><span class="line">            <span class="keyword">switch</span> (wmId)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> IDM_ABOUT:</span><br><span class="line">                <span class="built_in">DialogBox</span>(hInst, <span class="built_in">MAKEINTRESOURCE</span>(IDD_ABOUTBOX), hWnd, About);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IDM_EXIT:</span><br><span class="line">                <span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = <span class="built_in">BeginPaint</span>(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在此处添加使用 hdc 的任何绘图代码...</span></span><br><span class="line">            <span class="built_in">EndPaint</span>(hWnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>WndProc</code> 函数是一个事件处理函数，如同他前面标注的宏一样，他是一个 <code>CALLBACK</code> 函数（回调函数）。消息循环在获得消息后，该条消息就会被翻译、分发，分发函数再进行处理后回调 <code>WndProc</code> 函数处理事件，在程序段中，你可以看到该函数利用 <code>switch</code> 语句进行了事件类型的判别，并且对不同的事件类型做出了不同的回应。</p><h2 id="async-x2F-await：对事件驱动机制的进一步封装"><a href="#async-x2F-await：对事件驱动机制的进一步封装" class="headerlink" title="async &#x2F; await：对事件驱动机制的进一步封装"></a>async &#x2F; await：对事件驱动机制的进一步封装</h2><p><em>以下内容需要您有 JavaScript 编程的经验</em></p><p>JavaScript 与 C# 支持 async&#x2F;await 操作，这两个语言又正好是 GUI 开发的主力语言。这里笔者以 JavaScript 的 async&#x2F;await 操作为例，表明其与事件驱动机制的关联。下面是一则 JavaScript 拉取数据的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">useAPI</span>(<span class="string">&#x27;url...&#x27;</span>)</span><br><span class="line">    <span class="comment">//handle data...</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// useAPI 异步，他从网络的某个url拉取数据后将数据返回给变量data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JavaScript 引擎单线程，也就意味着跑在某个 JS 引擎上的一段代码不会并发，只会运行一处。事实上，JavaScript 的所有耗时异步操作全部由embedder（例如 libuv 等）提供支持，JS 自身只从 embedder 提供的 callback queue 中获得事件。</p><p><img src="https://felixgerschau.com/static/79486d91b22a7c1b4044fce88a4cae20/5a190/js-event-loop-explained.png" alt="js_event_queue"></p><p>js 引擎从 embedder 提供的 callback queue 获取事件并进行处理的机制，就叫做 event loop 机制。QuickJS 对 event loop 机制的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main loop which calls the user JS callbacks */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">js_std_loop</span><span class="params">(JSContext *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    JSContext *ctx1;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">/* execute the pending jobs */</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &amp;ctx1);</span><br><span class="line">            <span class="keyword">if</span> (err &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    js_std_dump_error(ctx1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!os_poll_func || os_poll_func(ctx))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>os_poll_func与上文提到的 <code>GetMessage</code>有着类似的行为。你会惊讶的发现，这两者的底层实现完全同构，只是 JavaScript 的事件循环机制被引擎给封装好了。</p><p>我们回到上面关于 async&#x2F;await 的讨论。首先，被挂上了 async 的函数，其最终返回的会是一个 Promise 对象。顾名思义，所以所有挂了 async 的函数，在调用时，会被当作一个异步函数对待。</p><p>JavaScript 的 async&#x2F;await 机制高妙的地方在于，他用 await 符阻塞了当前代码块，让原先本应当是<strong>回调函数</strong>的部分被以顺序控制流的形式展现出来。我们用另外两种代码书写方式（callback，链式调用）来重新书写以上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callbackStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useAPI</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;url...&#x27;</span>,<span class="attr">success</span>: handleData,<span class="attr">failed</span>: handleError&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">chainStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">uesAPI</span>(<span class="string">&#x27;url&#x27;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//handle data...</span></span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">  &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//async/await 调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">awaitAsyncStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">useAPI</span>(<span class="string">&#x27;url...&#x27;</span>)</span><br><span class="line">    <span class="comment">//handle data...</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// useAPI 异步，他从网络的某个url拉取数据后将数据返回给变量data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到，await&#x2F;async 机制让 JavaScript 用户不感受到自己正在写回调函数，在编写者看来，他们似乎利用 await 阻塞了当前的控制流。然而实际上，后面的代码块是作为回调函数出现的。</p><p>可以说，JS 利用 await&#x2F;async 机制（或者 Promise 链式调用机制），将消息循环（事件驱动机制）和回调屏蔽了，用户可以不和这两个东西打交道。但是理解 JS 的事件驱动机制的原理仍然是很重要的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术经历记录</title>
      <link href="/angrychow-blog/2023/01/21/Tech%20Stack%20%E8%AE%B0%E5%BD%95/"/>
      <url>/angrychow-blog/2023/01/21/Tech%20Stack%20%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="个人记录"><a href="#个人记录" class="headerlink" title="个人记录"></a>个人记录</h1><h2 id="2021-年-7月-9月"><a href="#2021-年-7月-9月" class="headerlink" title="2021 年 7月 - 9月"></a>2021 年 7月 - 9月</h2><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><ul><li>JAVA 程序设计复习</li><li>JAVA GUI，java.awt 与 java.swing 学习<ul><li>小项目：五子棋</li><li>JAVA 写 GUI 真屎</li></ul></li></ul><h3 id="BUPTCPC-第一年-with-ZYM-amp-XKD"><a href="#BUPTCPC-第一年-with-ZYM-amp-XKD" class="headerlink" title="BUPTCPC - 第一年 with ZYM &amp; XKD"></a>BUPTCPC - 第一年 with ZYM &amp; XKD</h3><ul><li>校赛准备<ul><li>结果：决赛铁牌（😅）</li></ul></li></ul><h3 id="Servlet-技术初探"><a href="#Servlet-技术初探" class="headerlink" title="Servlet 技术初探"></a>Servlet 技术初探</h3><ul><li>java - servlet技术 - tomcat<ul><li>小项目：作业记录CRUD，部署在别人（ZCW）的服务器上</li></ul></li></ul><h2 id="2021-年-10月-11月"><a href="#2021-年-10月-11月" class="headerlink" title="2021 年 10月 - 11月"></a>2021 年 10月 - 11月</h2><h3 id="SSM-框架初探"><a href="#SSM-框架初探" class="headerlink" title="SSM 框架初探"></a>SSM 框架初探</h3><ul><li>字节跳动，后端开发训练营<ul><li>项目：具有安全防护功能的账号系统</li></ul></li></ul><span id="more"></span><h3 id="React-框架学习"><a href="#React-框架学习" class="headerlink" title="React 框架学习"></a>React 框架学习</h3><ul><li>阅读蓝牙签到代码与 React 官方提供的文档</li></ul><h2 id="2021年-12月-2022年-1月"><a href="#2021年-12月-2022年-1月" class="headerlink" title="2021年 12月 - 2022年 1月"></a>2021年 12月 - 2022年 1月</h2><h3 id="React-框架应用"><a href="#React-框架应用" class="headerlink" title="React 框架应用"></a>React 框架应用</h3><ul><li>TailwindCSS（用类名代替 css 表）</li><li>微信小程序接口初探</li><li>不优雅的调后端接口，深刻理解 JavaScript 同步与异步<ul><li>项目：BOP 云上志愿者之家（微信小程序部分）</li></ul></li></ul><h3 id="GUI-再探"><a href="#GUI-再探" class="headerlink" title="GUI 再探"></a>GUI 再探</h3><ul><li><p>Win 32 程序开发学习，从操作系统的角度看窗体程序</p></li><li><p>C++ 程序设计再学习，学习C++的面向对象、泛型设计模式</p></li><li><p>Qt 框架学习，使用 Qt 封装的一系列库函数</p><ul><li>小项目：手动进行数据持久化的具有 GUI 界面的账号系统</li></ul></li></ul><h2 id="2022年-3月-6月"><a href="#2022年-3月-6月" class="headerlink" title="2022年 3月- 6月"></a>2022年 3月- 6月</h2><h3 id="第一次大作业"><a href="#第一次大作业" class="headerlink" title="第一次大作业"></a>第一次大作业</h3><ul><li>基于 Qt 框架的 “客车调度” 软件，非常简陋，但是 GUI 的各项要素齐全</li><li>学到了什么：<ul><li>手写画图，真的很痛苦，感谢现代编程工具</li><li><code>angrychow</code>宝刀未老，写代码一遍过，不需要调试</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(watched == <span class="keyword">this</span>-&gt;ui-&gt;widgetBus &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Paint) &#123;</span><br><span class="line">        <span class="type">int</span> widgetWidth = ui-&gt;widgetBus-&gt;<span class="built_in">width</span>();</span><br><span class="line">        <span class="type">int</span> widgetHeight = ui-&gt;widgetBus-&gt;<span class="built_in">height</span>();</span><br><span class="line">        <span class="function">QPainter <span class="title">paint</span><span class="params">(ui-&gt;widgetBus)</span></span>;</span><br><span class="line">        QPen widgetPen;</span><br><span class="line">        widgetPen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        widgetPen.<span class="built_in">setWidth</span>(<span class="number">2</span>);</span><br><span class="line">        paint.<span class="built_in">setPen</span>(widgetPen);</span><br><span class="line"></span><br><span class="line">        paint.<span class="built_in">drawLine</span>(<span class="number">20</span>,widgetHeight/<span class="number">2</span>,widgetWidth<span class="number">-20</span>,widgetHeight/<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> intervene = (widgetWidth<span class="number">-40</span>)/(stationNumber - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> nowDotPos = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=stationNumber;i++) &#123;</span><br><span class="line">            widgetPen.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">            paint.<span class="built_in">setPen</span>(widgetPen);</span><br><span class="line">            paint.<span class="built_in">drawPoint</span>(nowDotPos,widgetHeight/<span class="number">2</span>);</span><br><span class="line">            paint.<span class="built_in">drawText</span>(nowDotPos<span class="number">-10</span>,widgetHeight*<span class="number">3</span>/<span class="number">4</span>,<span class="built_in">QString</span>(<span class="string">&quot;车站&quot;</span>)+QString::<span class="built_in">number</span>(i));</span><br><span class="line">            nowDotPos+=intervene;</span><br><span class="line">        &#125;</span><br><span class="line">        widgetPen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        paint.<span class="built_in">setPen</span>(widgetPen);</span><br><span class="line">        paint.<span class="built_in">drawPoint</span>(<span class="number">20</span>+(<span class="type">int</span>)((<span class="type">float</span>)intervene*(<span class="type">float</span>)nowPosition/(<span class="type">float</span>)(<span class="built_in">g_getDistance</span>()/<span class="built_in">g_getTotalStation</span>())),widgetHeight/<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> centerX = <span class="number">20</span>+(<span class="type">int</span>)((<span class="type">float</span>)intervene*(<span class="type">float</span>)nowPosition/(<span class="type">float</span>)(<span class="built_in">g_getDistance</span>()/<span class="built_in">g_getTotalStation</span>()));</span><br><span class="line">        <span class="function">QRect <span class="title">busRect</span><span class="params">(centerX<span class="number">-10</span>,widgetHeight/<span class="number">4</span>,<span class="number">30</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">g_getNowDirection</span>()==CLOCKWISE) &#123;</span><br><span class="line">            paint.<span class="built_in">drawImage</span>(busRect,<span class="built_in">QImage</span>(<span class="string">&quot;:/static/bus_right.png&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paint.<span class="built_in">drawImage</span>(busRect,<span class="built_in">QImage</span>(<span class="string">&quot;:/static/bus_left.png&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        paint.<span class="built_in">drawText</span>(<span class="number">10</span>+(<span class="type">int</span>)((<span class="type">float</span>)intervene*(<span class="type">float</span>)nowPosition/(<span class="type">float</span>)(<span class="built_in">g_getDistance</span>()/<span class="built_in">g_getTotalStation</span>())),widgetHeight*<span class="number">7</span>/<span class="number">8</span>,<span class="built_in">QString</span>(<span class="string">&quot;车辆位置&quot;</span>));</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">g_getDistance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(watched==<span class="keyword">this</span>-&gt;ui-&gt;widgetSign&amp;&amp;event-&gt;<span class="built_in">type</span>()==QEvent::Paint) &#123;</span><br><span class="line">        QRect rect = <span class="keyword">this</span>-&gt;ui-&gt;widgetSign-&gt;<span class="built_in">rect</span>();</span><br><span class="line">        <span class="function">QPainter <span class="title">paint</span><span class="params">(<span class="keyword">this</span>-&gt;ui-&gt;widgetSign)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">g_getNowState</span>()==STATE_RUNNING) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">g_getNowDirection</span>()==CLOCKWISE) &#123;</span><br><span class="line">                paint.<span class="built_in">drawImage</span>(rect,<span class="built_in">QImage</span>(<span class="string">&quot;:/static/right_sign.png&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paint.<span class="built_in">drawImage</span>(rect,<span class="built_in">QImage</span>(<span class="string">&quot;:/static/left_sign.png&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paint.<span class="built_in">drawImage</span>(rect,<span class="built_in">QImage</span>(<span class="string">&quot;:/static/stop.png&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(watched,event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VUE-学习"><a href="#VUE-学习" class="headerlink" title="VUE 学习"></a>VUE 学习</h3><ul><li>Class-Based 重新学习前端</li></ul><h2 id="2022-年-7-月-9-月"><a href="#2022-年-7-月-9-月" class="headerlink" title="2022 年 7 月 - 9 月"></a>2022 年 7 月 - 9 月</h2><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li><p>重回丑陋的面向对象，利用 React 造出来机器人前端</p></li><li><p>堆物料库写了个北邮人数学挑战赛前端，但是这个事情黄了</p></li><li><p>学到了什么：</p><ul><li>理解了 JavaScript OOP 的重要性质：运行时作用域和名义作用域（this 指向问题）</li><li>理解了为什么 React 选择了函数式编程作为编程范式😅</li><li>物料库的随意组合往往比自己设计 css 要好看的多</li><li>利用 Data Bus 写了全局报错，绕过了 React 官方建议的 Provider 模式，确实很好用，但是违反结构化编程的原则，大项目不能这么干</li></ul></li></ul><h2 id="2022-年-10-月-12-月"><a href="#2022-年-10-月-12-月" class="headerlink" title="2022 年 10 月 - 12 月"></a>2022 年 10 月 - 12 月</h2><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><ul><li>toy code，用 Flutter 进行跨平台开发<ul><li>这事儿疑似半途而废了（截止 2023.1.21）</li><li>感觉不如 React Native</li><li>感觉不如 Electron</li></ul></li></ul><h3 id="BUPTCPC-第二年-with-MCY-amp-WH"><a href="#BUPTCPC-第二年-with-MCY-amp-WH" class="headerlink" title="BUPTCPC - 第二年 with MCY &amp; WH"></a>BUPTCPC - 第二年 with MCY &amp; WH</h3><ul><li>年度保留节目 </li><li>Result: 银牌🥈 正式队伍 14 名</li><li><code>angrychow</code>宝刀未老，写代码一遍过，不需要调试（dirty 率为 0，严查！）</li></ul><h2 id="2023-年-1-3-月"><a href="#2023-年-1-3-月" class="headerlink" title="2023 年 1-3 月"></a>2023 年 1-3 月</h2><h3 id="一期一会"><a href="#一期一会" class="headerlink" title="一期一会"></a>一期一会</h3><ul><li>略</li></ul><h2 id="2023-年-4-5-月"><a href="#2023-年-4-5-月" class="headerlink" title="2023 年 4-5 月"></a>2023 年 4-5 月</h2><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ul><li>Vue + ECharts</li><li>调接口很恶心</li><li>no new things</li></ul><h3 id="node-js，React"><a href="#node-js，React" class="headerlink" title="node.js，React"></a>node.js，React</h3><ul><li>学会用 node.js 快速起一个单线程异步后端服务</li><li>重新学习 js，背诵面经</li><li>用 React 糊了一个 DS 课设前端</li><li>玩了玩 Electron，Electron + React</li><li>看了看 React Native，简单配了一下环境。</li></ul><h3 id="java-OOP，计算机网络课程设计（DNS-Server-written-by-C）"><a href="#java-OOP，计算机网络课程设计（DNS-Server-written-by-C）" class="headerlink" title="java OOP，计算机网络课程设计（DNS Server written by C）"></a>java OOP，计算机网络课程设计（DNS Server written by C）</h3><ul><li>TCP，UDP 发包收包</li><li>实现了简单的多线程轮询服务器</li><li>用 ChatGPT 写了 java swing</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 复习用参考资料</title>
      <link href="/angrychow-blog/2023/01/21/csapp-%E6%9F%90%E5%B9%B4%E6%9C%9F%E6%9C%AB-%E5%8F%82%E8%80%83/"/>
      <url>/angrychow-blog/2023/01/21/csapp-%E6%9F%90%E5%B9%B4%E6%9C%9F%E6%9C%AB-%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="CSAPP-期末复习"><a href="#CSAPP-期末复习" class="headerlink" title="CSAPP 期末复习"></a>CSAPP 期末复习</h1><h2 id="CSAPP-某年期末"><a href="#CSAPP-某年期末" class="headerlink" title="CSAPP 某年期末"></a>CSAPP 某年期末</h2><h3 id="判断题-2pts-8-x3D-16pts"><a href="#判断题-2pts-8-x3D-16pts" class="headerlink" title="判断题 2pts * 8&#x3D;16pts"></a>判断题 2pts * 8&#x3D;16pts</h3><p>1-1 <code>(x|-x)&gt;&gt;31 == -1</code> x 的类型是 int</p><p>1-2 UNIX 系统中，文件就是字节序列，每个I&#x2F;O设备都可以看成文件。</p><p>1-3 <code>-1 &lt; 0U</code></p><p>1-4 <code>cmpq (%rax), 6(%rsp)</code></p><span id="more"></span><p>1-5 fork 调用一次，返回两次</p><p>1-6 <code>x&gt;&gt;3==x/8</code></p><p>1-7 连接器的两个主要任务是符号解析和地址重定位</p><p>1-8 <code>lea %r12, 0x2006ae(%rip)</code></p><h3 id="单选题-2pts-20-x3D-40pts"><a href="#单选题-2pts-20-x3D-40pts" class="headerlink" title="单选题 2pts * 20 &#x3D; 40pts"></a>单选题 2pts * 20 &#x3D; 40pts</h3><p>2-1 运行 C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> si = <span class="number">-128</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> usi = si;</span><br></pre></td></tr></table></figure><p>那么<code>usi</code>的值是：</p><ul><li>A. 65407</li><li>B. 128</li><li>C. 65408</li><li>D. 127</li></ul><p>2-2 对于下面两个程序<br><code>a1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  f();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  x = <span class="number">15212</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行命令 <code>gcc -o foo a1.c a2.c</code>，接着执行 foo 后，x的输出结果是</p><ul><li>A. 15213</li><li>B. 15212</li><li>垃圾选项</li></ul><p>2-3 对于某8位计算机，整数用补码表示，假设x&#x3D;60，y&#x3D;-30，则x+y的机器数以及相对应的OF（1为溢出，0为不溢出）为：</p><ul><li>A. 0x1E, 0</li><li>B. 0xE2, 1</li><li>C. 0x1E, 1</li><li>D. 0xE2, 0</li></ul><p>2-4 对于 gcc 工具链而言，cpp、ccl、as、ld 分别代表着：</p><ul><li>A. 编译器、预处理器、链接器、汇编器</li><li>B. 编译器、预处理器、汇编器、链接器</li><li>C. 预处理器、链接器、编译器、汇编器</li><li>D. 预处理器、编译器、汇编器、链接器</li></ul><p>2-5 已知变量 y 的类型是 float，位于地址 0x400 处，它的十六进制为 0x01234567，在采用小端模式存储的机器中，地址范围为 0x400 ~ 0x403 处存储的字节依次为：</p><ul><li>A. 0x67 0x45 0x23 0x01</li><li>B. 0x01 0x23 0x45 0x67</li><li>垃圾选项</li></ul><p>2-6 十六位补码整数的范围</p><ul><li>A. $-2^{15}\sim +(2^{15}-1)$</li><li>B. $-(2^{15}-1)\sim +(2^{15}-1)$</li><li>C. $-2^{16}\sim +(2^{16}-1)$</li><li>D. $-(2^{16}-1)\sim +(2^{16}-1)$</li></ul><p>2-7 采用 GCC 工具链 将下述 C 语言程序编译成汇编代码，请问代码中<code>x</code>,<code>des</code>分别存储在哪个寄存器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> des)</span> &#123;</span><br><span class="line">  <span class="type">long</span> t = sum(x,y);</span><br><span class="line">  des = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A. rsi, rcx</li><li>B. rdi, rdx</li><li>C. rsi, rdi</li><li>D. rdx, rsi</li></ul><p>2-8 “缺页”属于异常中的：</p><ul><li>A. 中断</li><li>B. 终止</li><li>C. 陷阱</li><li>D. 故障</li></ul><p>2-9 某些情况下 read 和 write 传送的字节数比程序要求的要少，这些不足值出现的原因包括</p><ul><li>A. 读到EOF</li><li>B. 从终端读文本行</li><li>C. 读取网络套字节</li><li>D. 典中典之以上都正确</li></ul><p>2-10 链接可以发生在哪个阶段？最正确的答案是</p><ul><li>A. 加载时</li><li>B. 运行时</li><li>C. 编译时</li><li>D. 典中典之以上都正确</li></ul><p>2-11 在 Linux 下，下列哪个命令行可以将 C 程序 <code>test.c</code> 编译生成可执行文件</p><ul><li>A. <code>objdump -d test.o</code></li><li>B. <code>gcc -O1 -o result test.o</code></li><li>C. <code>gcc -Og -o result test.c</code></li><li>D. <code>gcc -Og -c test test.c</code></li></ul><p>2-12 表示传送字节的指令是</p><ul><li>A. movw</li><li>B. movq</li><li>C. movb</li><li>D. movl</li></ul><p>2-13 下列寄存器中，不属于被调用者保存寄存器的是</p><ul><li>A. r12</li><li>B. rbp</li><li>C. rbx</li><li>D. rax</li></ul><p>2-14 设数组<code>short = T[3]</code>。假设数组的起始地址为$x_t$，则<code>T[2]</code>的地址是</p><ul><li>A. $x_t+8$</li><li>B. $x_t+4$</li><li>C. $x_t+16$</li><li>D. $x_t+2$</li></ul><p>2-15 假设 p 为一个 char* 类型的指针，他的值为 $x$，则表达式 <code>(int*)p+7</code>的值为</p><ul><li>A. $4x+28$</li><li>B. $4x+7$</li><li>C. $x+28$</li><li>D. $x+7$</li></ul><p>2-16 异常中异步发生的是</p><ul><li>A. 中断</li><li>B. 故障</li><li>C. 终止</li><li>D. 陷阱</li></ul><p>2-17 已知寄存器<code>rax</code>的值为0x0011223344556677,执行指令<code>movl $-1, %eax</code>，则<code>rax</code>的值变为：</p><ul><li>A. 0x00000000FFFFFFFF</li><li>B. 0x000000000000FFFF</li><li>C. 0x00112233FFFFFFFF</li><li>D. 0x001122330000FFFF</li></ul><p>2-18 已知地址0x100的值为0xff，地址0x104的值为0xab，地址0x108的值为0x13，地址0x10c的值为0x11，寄存器%rax的值为0x100，寄存器%rdx的值为0x3，则操作数<code>9(%rax,%rdx)</code>代表的值是</p><ul><li>A. 0xff</li><li>B. 0xab</li><li>C. 0x13</li><li>D. 0x11</li></ul><p>2-19  下面关于 Unix I&#x2F;O 的叙述中，不正确的是</p><ul><li>A. 可以读取文件的元数据</li><li>B. 允许执行I&#x2F;O重定向</li><li>C. Unix I&#x2F;O 可以完成的事情，标准I&#x2F;O 也可以完成</li><li>D. 将一个打开的文件模型化为一个流</li></ul><p>2-20 已知IEEE754单精度浮点数的值为0xC0B00000，他的十进制是：</p><ul><li>A. -5.5</li><li>B. -0.75</li><li>C. -1.5</li><li>D. -2.75</li></ul><h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><p>4-1 （1pts*10&#x3D;10pts）<br>若某机器为6位，有符号数int用补码表示，填写下表（1）-（10），有如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">usigned ux = x;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>十进制表示</th><th>二进制表示</th></tr></thead><tbody><tr><td>零</td><td>0</td><td>000000</td></tr><tr><td>-</td><td>-10</td><td>(5)</td></tr><tr><td>x</td><td>-1</td><td>(6)</td></tr><tr><td>ux</td><td>(1)</td><td>(7)</td></tr><tr><td>x&gt;&gt;1</td><td>(2)</td><td>(8)</td></tr><tr><td>TMin</td><td>(3)</td><td>(9)</td></tr><tr><td>TMin+TMin</td><td>(4)</td><td>(10)</td></tr></tbody></table><p>4-2(2pts*3&#x3D;6pts)<br>分析下表左侧汇编代码，找出右侧唯一等价的 C 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">foo1:</span><br><span class="line">  lea 0xf(%rdi), %eax</span><br><span class="line">  test %edi, %edi</span><br><span class="line">  comvns %edi, %eax</span><br><span class="line">  sar $0x4, %eax</span><br><span class="line">  retq</span><br><span class="line"></span><br><span class="line">foo2:</span><br><span class="line">  mov %edi, %eax</span><br><span class="line">  shr $0x1f, %eax</span><br><span class="line">  retq</span><br><span class="line"></span><br><span class="line">foo3:</span><br><span class="line">  mov %edi, %eax</span><br><span class="line">  sal %0x4, %eax</span><br><span class="line">  sub %edi, %eax</span><br><span class="line">  retq</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">choice1</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">choice2</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">choice3</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">15</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">choice4</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + <span class="number">15</span>)/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">choice5</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x / <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">choice6</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>foo1 对应choice____</li><li>foo2 对应choice____</li><li>foo3 对应choice____</li></ol><p>4-3 求M、N（8分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> mat1[M][N];</span><br><span class="line"><span class="type">long</span> mat2[N][M];</span><br><span class="line"><span class="type">long</span> <span class="title function_">sum_element</span><span class="params">(<span class="type">long</span> i,<span class="type">long</span> j)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mat1[i][j]+mat2[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum_element:</span><br><span class="line">  leaq (%rdi,%rdi,2)%rdx</span><br><span class="line">  addq %rsi,%rdx</span><br><span class="line">  leaq (%rdi,rdi,8), %rax</span><br><span class="line">  addq %rax,%rsi</span><br><span class="line">  movq mat2(,%rsi,8),%rax</span><br><span class="line">  addq mat1(,%rdx,8),%rax</span><br><span class="line">  retq</span><br></pre></td></tr></table></figure><p>4-4 程序完形填空（8分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">  movl $0,%eax</span><br><span class="line">  jmp .L2</span><br><span class="line">.L3:</span><br><span class="line">  subl $1,%edi</span><br><span class="line">  addl $1,%esi</span><br><span class="line">  addl $1,%eax</span><br><span class="line">.L2:</span><br><span class="line">  cmpl %esi,%edi</span><br><span class="line">  jg .L3</span><br><span class="line">  addl $1,%eax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">for</span>((<span class="number">1</span>)____;(<span class="number">2</span>)____;result++) &#123;</span><br><span class="line">    (<span class="number">3</span>)____;</span><br><span class="line">    (<span class="number">4</span>)____;</span><br><span class="line">  &#125;</span><br><span class="line">  result ++;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4-5 阅读下列代码，回答以下问题（12分）<br>调用 bar 函数时，参数 x 的值是 0xaabbccdd，且在响应gets时键入’01234567890123456’，分析下表中给出的代码，然后回答以下问题。<br>（提示：1、get是标准库函数，%rdi存放的是输入缓冲区等候地址。2、x86处理器小端存储。3、’0’-‘9’的字符ASCII码为0x30-0x39）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">push %rbp</span><br><span class="line">mov %rsp,%rbp</span><br><span class="line">sub $0x30,%rsp</span><br><span class="line">mov %edi,-0x24(%rbp)</span><br><span class="line">movl $0x11223344, -0x10(%rbp)</span><br><span class="line">mov -0x24(%rbp),%eax</span><br><span class="line">mov %eax, -0xc(%rbp)</span><br><span class="line">lea -0x20(%rbp),%rax</span><br><span class="line">mov %rax,%rdi</span><br><span class="line">mov $0x0,%eax</span><br><span class="line">callq 0x400450&lt;gets@plt&gt;</span><br><span class="line">mov -0xc(%rbp),%edx</span><br><span class="line">mov -0x10(%rbp),%eax</span><br><span class="line">lea -0x20(%rbp),%rcx</span><br><span class="line">mov %eax,%esi</span><br><span class="line">mov $0x400654,%edi</span><br><span class="line">mov $0x0,%eax</span><br><span class="line">callq 0x400430 &lt;printf@plt&gt;</span><br><span class="line">nop</span><br><span class="line">mov %rbp,%rsp</span><br><span class="line">pop %rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0x11223344</span>;</span><br><span class="line">  a[<span class="number">1</span>] = x;</span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a[0]=0x%x,a[1]=0x%x,buf=%s\n&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a) 指出程序中下列值是否被溢出破坏(2pts*4&#x3D;8pts)</p><ul><li>a[0] (y&#x2F;n)</li><li>a[1] (y&#x2F;n)</li><li>x 的值 (y&#x2F;n)</li><li>寄存器 %rbp 保存的值 (y&#x2F;n)</li></ul><p>b) 程序打印结果为(1pts*3&#x3D;3pts)</p><ul><li>a[0]:0x_____________</li><li>a[1]:0x_____________</li><li>buf(ASCII):_________</li></ul><p>c) 如果编写C程序调用上述bar函数，问：（1pts）</p><ul><li>当输入到第____个字符后无法从bar函数正常返回。</li></ul><h2 id="CSAPP-往年期末题-参考"><a href="#CSAPP-往年期末题-参考" class="headerlink" title="CSAPP 往年期末题 参考"></a>CSAPP 往年期末题 参考</h2><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>1-1 错误，$x&#x3D;0$时，<code>(x|-x)&gt;&gt;31</code>为0。</p><p>1-2 正确，PPT 原话</p><p>1-3 错误，运算与比较中出现无符号数时有符号数转为无符号数，左端<code>-1</code>转为无符号数<code>(1u&lt;&lt;31)</code></p><p>1-4 错误，指令两端不能同时操作内存。</p><p>1-5 正确，这是<code>fork</code>函数的特征。</p><p>1-6 错误，<code>x&gt;&gt;3</code>向下舍入，<code>x/8</code>向0舍入。</p><p>1-7 正确</p><p>1-8 错误，load effective address 指令（lea）的目的操作数必须是一个寄存器（中文版P129）</p><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p>2-1 B<br>short 两字节，转换为无符号数为65408。</p><p>2-2 B<br>补充：上面那一段是a1.c，下面那一段时a2.c</p><p>编译时，a2.c中的变量<code>x</code>是弱符号，归入a1.c中的强符号<code>x</code>中，函数<code>f</code>对其产生的引用对全局的<code>x</code>变量产生影响。</p><p>2-3 A<br>注意，OF（Overflow Flag）针对的是有符号数溢出；这里的运算没有发生有符号数溢出，所以为0。值得注意的是$-30+60&#x3D;(1110<del>0010)+(0011</del>1100)$发生无符号数溢出，CF（Carry Flag）为1。</p><p>2-4 D</p><p>2-5 A<br>小端法内存低位存数据低位，大端法内存地位存数据高位。</p><p>2-6 A</p><p>2-7 原问题补充：<code>x</code>和<code>des</code>分别存储在寄存器 B</p><p>2-8 D</p><ul><li>中断：设备IO，异步发生。</li><li>陷阱：<code>syscall</code>，向内核进行请求，同步发生，总能返回原进程。</li><li>故障：出现问题（例如缺页），可能出错，不一定能返回原进程，同步发生。</li><li>终止：发生致命错误，同步发生，原进程停止。</li></ul><p>2-9 D</p><p>2-10 D<br>动态链接库可以在多个阶段进行链接</p><p>2-11 C</p><ul><li><code>gcc -o</code>：可执行文件</li><li><code>gcc -S</code>：汇编文件</li><li><code>gcc -c</code>：可重定位文件</li><li><code>objdump -d</code>：二进制文件反汇编</li></ul><p>2-12 C</p><p>2-13 D<br>书上没有显式指明<code>%rax</code>是调用者保存，但是<code>%rax</code>的功能是保存被调用者返回值，显然<code>%rax</code>的值在调用者调用前是需要调用者自己保存的。</p><p>2-14 B<br>$\mathrm{ADDR}[&amp;T[i]]&#x3D;x_{t}+\mathrm{sizeof}(T[i])*(i)$</p><p>2-15 C<br>指针类型强制转换不会改变其内部的值，$val(\mathrm{pointer}+\mathrm{offset})&#x3D;val(\mathrm{pointer})+\mathrm{sizeof}(\mathrm{pointer}指向的类型)*\mathrm{offset}$</p><p>2-16 A</p><p>2-17 A<br><code>movl</code>高32位清零。</p><p>2-18 D</p><p>2-19 C<br>标准IO库不适用于网络套字节的IO，并且标准IO不能读取文件的元数据。</p><p>2-20 rectify:他的十进制是 A<br>$\mathrm{0xC0B00000}&#x3D;(\mathrm{1<del>10000001</del>011}),\mathrm{sign}&#x3D;-1,\mathrm{Exponent}&#x3D;129-\mathrm{bias}&#x3D;2,M&#x3D;1+f&#x3D;1.375$</p><h3 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h3><p>4-1</p><table><thead><tr><th>表达式</th><th>十进制表示</th><th>二进制表示</th></tr></thead><tbody><tr><td>零</td><td>0</td><td>000000</td></tr><tr><td>-</td><td>-10</td><td><strong>110110</strong></td></tr><tr><td>x</td><td>-1</td><td><strong>111111</strong></td></tr><tr><td>ux</td><td><strong>63</strong></td><td><strong>111111</strong></td></tr><tr><td>x&gt;&gt;1</td><td><strong>-1</strong></td><td><strong>111111</strong></td></tr><tr><td>TMin</td><td><strong>-32</strong></td><td><strong>100000</strong></td></tr><tr><td>TMin+TMin</td><td><strong>0</strong></td><td><strong>000000</strong></td></tr></tbody></table><p>4-2</p><ol><li>foo1 对应choice<strong>5</strong><ul><li>他这里做的是从向下舍入除法变为向零舍入除法。</li></ul></li><li>foo2 对应choice<strong>2</strong><ul><li>注意<code>foo2</code>进行的是逻辑右移</li></ul></li><li>foo3 对应choice<strong>3</strong><ul><li>很典型的乘法二进制拆分</li></ul></li></ol><p>4-3</p><p>汇编进行一下简单翻译，就是：<code>return *(mat1+3*i+j)+*(mat2+9*i+j)</code></p><p>不难得知$N&#x3D;3,M&#x3D;9$</p><p>4-4</p><p>在这里，编译器用jump-to-middle法翻译for循环。</p><ol><li><code>result = 0</code></li><li><code>y &lt; x</code></li><li><code>x--</code></li><li><code>y++</code></li></ol><p>4-5</p><ul><li><code>a[0]</code> 被破坏</li><li><code>a[1]</code> 不被破坏</li><li><code>x</code>的值没有被破坏（x的值被保存在了-0x24(%rbp)，没有被栈溢出攻击）</li><li><code>rbp</code>中的值没有被破坏</li><li>$\mathrm a[0]&#x3D;\mathrm{0x11220036}$</li><li>$\mathrm a[1]&#x3D;\mathrm{0xaabbccdd}$</li><li>buf&#x3D;01234567890123456</li><li>当输入到第<strong>32</strong>个字符后无法从bar函数正常返回。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32 GUI 编程初探合集</title>
      <link href="/angrychow-blog/2023/01/21/Win32-GUI-%E7%BC%96%E7%A8%8B-%E5%90%88%E9%9B%86/"/>
      <url>/angrychow-blog/2023/01/21/Win32-GUI-%E7%BC%96%E7%A8%8B-%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Win32-GUI-编程-1-1-intro"><a href="#Win32-GUI-编程-1-1-intro" class="headerlink" title="Win32 GUI 编程 1.1 intro"></a>Win32 GUI 编程 1.1 intro</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>了解什么是回调函数</li><li>了解句柄概念</li></ul><h3 id="窗口创建的过程"><a href="#窗口创建的过程" class="headerlink" title="窗口创建的过程"></a>窗口创建的过程</h3><ul><li>定义 WinMain 函数</li><li>定义窗口处理函数（自定义，消息处理回调）</li><li>向操作系统注册窗口类（向操作系统写入数据）</li><li>创建窗口（内存中创建窗口）</li><li>显示窗口（绘制窗口）</li><li>消息循环（获取、翻译、分发消息）</li><li>消息处理</li></ul><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中出现的宏定义：</span></span><br><span class="line"><span class="comment">HINSTANCE：整个程序的句柄（不恰当的比方：指向整个结构体的指针）</span></span><br><span class="line"><span class="comment">HWND：指向整个程序的某一个窗口的句柄（不恰当的比方：指向结构体的某个成员的指针）</span></span><br><span class="line"><span class="comment">LPSTR：Long Pointer String，本质是char *</span></span><br><span class="line"><span class="comment">CALLBACK：人如其名，回调。</span></span><br><span class="line"><span class="comment">LRESULT：Long Result，本质是long</span></span><br><span class="line"><span class="comment">UINT：Unsigned Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义，处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">// 传入某个窗口的句柄，操作系统告诉你是哪个窗口遇到了需要处理的事件</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT msgID, <span class="comment">// 传入窗口发生的事件，操作系统告诉你当前窗口发生了什么事情</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, <span class="comment">//附加参数 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam <span class="comment">//附加参数 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd,msgID,wParam,lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWINDOWBUFFER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASSBUFFER 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hIns, <span class="comment">//当前程序句柄，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPerIns, <span class="comment">//前一个程序句柄，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPSTR lpCmdLine, <span class="comment">//由此可获取命令行输入的命令</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nCmdShow <span class="comment">// 当前的显示状态，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建窗口类，或者说是新建一个窗口，开始设定窗口的属性</span></span><br><span class="line">WNDCLASS mainWindow = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mainWindow.cbClsExtra = MYCLASSBUFFER;<span class="comment">//给窗口设定 class 缓冲区</span></span><br><span class="line">mainWindow.cbWndExtra = MYWINDOWBUFFER;<span class="comment">//给窗口设定 window 缓冲区</span></span><br><span class="line">mainWindow.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">//给窗口设定颜色，这里是白色</span></span><br><span class="line">mainWindow.hCursor = <span class="literal">NULL</span>; <span class="comment">//光标（Cursor）进入窗体时，使用默认光标，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hIcon = <span class="literal">NULL</span>; <span class="comment">//窗体的Icon使用默认Icon，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hInstance = hIns;<span class="comment">//窗口的程序句柄</span></span><br><span class="line">mainWindow.lpfnWndProc = WndProc;<span class="comment">//窗口处理函数，以便于回调</span></span><br><span class="line">mainWindow.lpszClassName = <span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>);<span class="comment">//窗口的类的名字</span></span><br><span class="line">mainWindow.lpszMenuName = <span class="literal">NULL</span>; <span class="comment">//窗口的菜单的名字，NULL表示没有</span></span><br><span class="line">mainWindow.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//风格，为什么是常量通过与运算来确定，你点进常量里面看一看就懂了（Hint：二进制）。具体有哪些属性可以查微软API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口属性填入完毕，注册窗口类，将以上所有赋值全部写入操作系统</span></span><br><span class="line"><span class="built_in">RegisterClass</span>( &amp;mainWindow );</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口，返回一个句柄</span></span><br><span class="line">HWND mainWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>), <span class="comment">// 创建哪个窗口，这里显然我们想要创建刚刚注册的那个窗口，这里传入的类名要和前面的一样</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>), <span class="comment">// 窗口的标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口的风格</span></span><br><span class="line"><span class="number">100</span>, <span class="comment">//窗口的位置数据，x,y,width,height</span></span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//这个窗口有没有父窗口（eg.QQ密码登陆错误，跳出来一个报错消息框，报错消息框是QQ登录窗口的子窗口） 没有就传NULL</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//这个窗口有没有菜单，没有传NULL</span></span><br><span class="line">hIns, <span class="comment">//这个窗口从属于哪个程序，传句柄</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//这个窗口有没有别的参数</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//注意，创建了窗口!=窗口被操作系统显示，我们要调用函数让操作系统显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(</span><br><span class="line">mainWindowHandle,<span class="comment">//传入想要显示的窗口的句柄</span></span><br><span class="line">SW_SHOW <span class="comment">//显示的方法，具体可查API</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">UpdateWindow</span>( mainWindowHandle ); <span class="comment">//刷新窗口，不写也行，就是说明有这个玩意</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">消息循环</span></span><br><span class="line"><span class="comment">窗口程序之所以你不去点他他就一直存在，是因为存在消息循环一直在执行。</span></span><br><span class="line"><span class="comment">通过消息循环，整个程序不断地去检测你对整个程序干了些什么事情，然后对你的行动做出相应反应。</span></span><br><span class="line"><span class="comment">GetMessage返回值：</span></span><br><span class="line"><span class="comment">如果函数取得WM_QUIT之外的其他消息，返回非零值。</span></span><br><span class="line"><span class="comment">如果函数取得WM_QUIT消息，返回值是零。</span></span><br><span class="line"><span class="comment">如果出现了错误，返回值是-1。</span></span><br><span class="line"><span class="comment">若想获得更多的错误信息，请调用GetLastError函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MSG msgLoop = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(</span><br><span class="line">&amp;msgLoop , <span class="comment">// GetMessage向msgLoop丢消息</span></span><br><span class="line"><span class="literal">NULL</span> , <span class="comment">// 取得其消息的窗口的句柄。当其值取NULL时，GetMessage会去取我们写的程序的所有窗口发生的事件</span></span><br><span class="line"><span class="number">0</span> , <span class="comment">// 指定被检索的最小消息值，现在不用管这个</span></span><br><span class="line"><span class="number">0</span>  <span class="comment">// 指定被检索的最大消息值，现在不用管这个</span></span><br><span class="line">)) &#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msgLoop);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msgLoop); </span><br><span class="line"><span class="comment">// 分发消息，也就是交给WndProc来处理msg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Win32-GUI-编程-1-2-窗口"><a href="#Win32-GUI-编程-1-2-窗口" class="headerlink" title="Win32 GUI 编程 1.2 窗口"></a>Win32 GUI 编程 1.2 窗口</h2><h3 id="窗口类是什么"><a href="#窗口类是什么" class="headerlink" title="窗口类是什么"></a>窗口类是什么</h3><ul><li><p>窗口类包含了窗口的各种参数信息的一种结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建窗口类，或者说是新建一个窗口，开始设定窗口的属性</span></span><br><span class="line">WNDCLASS mainWindow = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mainWindow.cbClsExtra = MYCLASSBUFFER;<span class="comment">//给窗口设定 class 缓冲区</span></span><br><span class="line">mainWindow.cbWndExtra = MYWINDOWBUFFER;<span class="comment">//给窗口设定 window 缓冲区</span></span><br><span class="line">mainWindow.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">//给窗口设定颜色，这里是白色</span></span><br><span class="line">mainWindow.hCursor = <span class="literal">NULL</span>; <span class="comment">//光标（Cursor）进入窗体时，使用默认光标，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hIcon = <span class="literal">NULL</span>; <span class="comment">//窗体的Icon使用默认Icon，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hInstance = hIns;<span class="comment">//窗口的程序句柄</span></span><br><span class="line">mainWindow.lpfnWndProc = WndProc;<span class="comment">//窗口处理函数，以便于回调</span></span><br><span class="line">mainWindow.lpszClassName = <span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>);<span class="comment">//窗口的类的名字</span></span><br><span class="line">mainWindow.lpszMenuName = <span class="literal">NULL</span>; <span class="comment">//窗口的菜单的名字，NULL表示没有</span></span><br><span class="line">mainWindow.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//风格，为什么是常量通过与运算来确定，你点进常量里面看一看就懂了（Hint：二进制）。具体有哪些属性可以查微软API</span></span><br></pre></td></tr></table></figure></li><li><p>每个窗口都有窗口类，每个窗口基于自己的窗口类创建窗口。</p></li><li><p>每一个窗口类都有一个名称，使用前必须注册到系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RegisterClass</span>( &amp;mainWindow );</span><br></pre></td></tr></table></figure></li></ul><h3 id="窗口类分类"><a href="#窗口类分类" class="headerlink" title="窗口类分类"></a>窗口类分类</h3><ul><li><p>系统窗口类</p><p>​系统已经定义好的窗口类，应用程序拿来就用</p></li><li><p>应用程序全局窗口类</p><p>​由用户自己定义，当前应用程序可用</p></li><li><p>应用程序局部窗口类</p><p>​由用户自己定义，当前应用程序中本模块可以使用</p></li></ul><h4 id="系统窗口类"><a href="#系统窗口类" class="headerlink" title="系统窗口类"></a>系统窗口类</h4><p>​example：</p><p>​按钮 - BUTTON</p><p>​编辑框 - EDIT</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWINDOWBUFFER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASSBUFFER 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hIns,</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPerIns,</span></span></span><br><span class="line"><span class="params"><span class="function">LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">HWND mainWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Button&quot;</span>), <span class="comment">//系统内置的类，不用自己写</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>),</span><br><span class="line">WS_OVERLAPPEDWINDOW,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">ShowWindow</span>(</span><br><span class="line">mainWindowHandle,</span><br><span class="line">SW_SHOW</span><br><span class="line">);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(mainWindowHandle);</span><br><span class="line">MSG msgLoop = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(</span><br><span class="line">&amp;msgLoop,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">)) &#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msgLoop);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msgLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局窗口类、局部窗口类"><a href="#全局窗口类、局部窗口类" class="headerlink" title="全局窗口类、局部窗口类"></a>全局窗口类、局部窗口类</h4><p>注册窗口类的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ATOM <span class="title">RegisterClass</span><span class="params">(CONST WNDCLASS *lpWndClass)</span></span>; <span class="comment">//传入窗口类</span></span><br></pre></td></tr></table></figure><p>补充：ATOM是原子操作的意思，意味着当程序执行到一个ATOM类型的函数时不可以被操作系统打断，必须一次性执行完毕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WNDCLASS</span> &#123;</span><br><span class="line">    UINT style; <span class="comment">//窗口类的风格</span></span><br><span class="line">    WNDPROC lpfnWndProc; <span class="comment">//窗口处理函数</span></span><br><span class="line">    <span class="type">int</span> cbClsExtra;<span class="comment">//窗口类的附加数据缓存大小</span></span><br><span class="line">    <span class="type">int</span> cbWndExtra;<span class="comment">//窗口的附加数据缓存大小</span></span><br><span class="line">    HINSTANCE hInstance;<span class="comment">//当前模块的程序句柄（区别程序（实例）句柄和窗口句柄）</span></span><br><span class="line">    HICON hIcon;<span class="comment">//icon</span></span><br><span class="line">    HCURSOR hCursor;<span class="comment">//cursor</span></span><br><span class="line">    HBRUSH hbrBackground;<span class="comment">//background</span></span><br><span class="line">    LPCTSTR lpszMenuName;<span class="comment">//窗口菜单的资源ID字符串</span></span><br><span class="line">    LPCTSTR lpszClassName;<span class="comment">//窗口类的名称</span></span><br><span class="line">&#125;WNDCLASS,*PWNDCLASS;</span><br></pre></td></tr></table></figure><h3 id="窗口类创建"><a href="#窗口类创建" class="headerlink" title="窗口类创建"></a>窗口类创建</h3><ul><li>CreateWindow &#x2F; CreateWindowEx</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateWindowEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">DWRD dwExStyle,<span class="comment">//Ex独有属性，扩展风格</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpClassName,<span class="comment">//已经注册的窗口类名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpWindowName<span class="comment">//窗口标题栏的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwStyle,<span class="comment">//窗口的基本风格</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> x,<span class="comment">//窗口左上角水平坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> y,<span class="comment">//窗口左上角垂直坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nWidth,<span class="comment">//窗口宽度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nHeight,<span class="comment">//窗口高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent,<span class="comment">//窗口的父窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HMENU hMenu,<span class="comment">//窗口菜单句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,<span class="comment">//应用程序的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParam<span class="comment">//窗口创建时的附加参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//创建成功后返回窗口句柄</span></span><br></pre></td></tr></table></figure><p>这个函数干了什么：你可以认为这个函数疯狂的 malloc 了一大堆信息</p><p>关于 dwStyle：<a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles">https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles</a></p><ul><li><p>CreateWindow 执行过程：</p><p>1、函数根据传入的名称，在<strong>应用程序局部窗口类</strong>中查找，如果找到执行2，未找到执行3.</p><p>2、比较局部窗口类与创建窗口时传入的hInstance变量。如果相等，创建和注册的窗口类在同一模块，创建窗口返回。如果不相同，执行3。</p><p>3、在应用程序全局窗口类查找，如果找到，执行4，未找到执行5。</p><p>4、使用找到的窗口类信息，创建窗口并返回。</p><p>5、在系统窗口类中查找，如果找到，创建窗口并返回；否则执行失败。</p></li><li><p>创建子窗口：</p><ul><li>创建时，设置父窗口句柄</li><li>创建时，风格增加：WS_CHILD|WS_VISIBLE</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中出现的宏定义：</span></span><br><span class="line"><span class="comment">HINSTANCE：整个程序的句柄（不恰当的比方：指向整个结构体的指针）</span></span><br><span class="line"><span class="comment">HWND：指向整个程序的某一个窗口的句柄（不恰当的比方：指向结构体的某个成员的指针）</span></span><br><span class="line"><span class="comment">LPSTR：Long Pointer String，本质是char *</span></span><br><span class="line"><span class="comment">CALLBACK：人如其名，回调。</span></span><br><span class="line"><span class="comment">LRESULT：Long Result，本质是long</span></span><br><span class="line"><span class="comment">UINT：Unsigned Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义，处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">// 传入某个窗口的句柄，操作系统告诉你是哪个窗口遇到了需要处理的事件</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT msgID, <span class="comment">// 传入窗口发生的事件，操作系统告诉你当前窗口发生了什么事情</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, <span class="comment">//附加参数 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam <span class="comment">//附加参数 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY: &#123;</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWINDOWBUFFER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASSBUFFER 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hIns, <span class="comment">//当前程序句柄，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPerIns, <span class="comment">//前一个程序句柄，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPSTR lpCmdLine, <span class="comment">//由此可获取命令行输入的命令</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nCmdShow <span class="comment">// 当前的显示状态，操作系统传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建窗口类，或者说是新建一个窗口，开始设定窗口的属性</span></span><br><span class="line">WNDCLASS mainWindow = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mainWindow.cbClsExtra = MYCLASSBUFFER;<span class="comment">//给窗口设定 class 缓冲区</span></span><br><span class="line">mainWindow.cbWndExtra = MYWINDOWBUFFER;<span class="comment">//给窗口设定 window 缓冲区</span></span><br><span class="line">mainWindow.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">//给窗口设定颜色，这里是白色</span></span><br><span class="line">mainWindow.hCursor = <span class="literal">NULL</span>; <span class="comment">//光标（Cursor）进入窗体时，使用默认光标，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hIcon = <span class="literal">NULL</span>; <span class="comment">//窗体的Icon使用默认Icon，你也可以传进来一个图片</span></span><br><span class="line">mainWindow.hInstance = hIns;<span class="comment">//窗口的程序句柄</span></span><br><span class="line">mainWindow.lpfnWndProc = WndProc;<span class="comment">//窗口处理函数，以便于回调</span></span><br><span class="line">mainWindow.lpszClassName = <span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>);<span class="comment">//窗口的类的名字</span></span><br><span class="line">mainWindow.lpszMenuName = <span class="literal">NULL</span>; <span class="comment">//窗口的菜单的名字，NULL表示没有</span></span><br><span class="line">mainWindow.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//风格，为什么是常量通过与运算来确定，你点进常量里面看一看就懂了（Hint：二进制）。具体有哪些属性可以查微软API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口属性填入完毕，注册窗口类，将以上所有赋值全部写入操作系统</span></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;mainWindow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中创建窗口，返回一个句柄</span></span><br><span class="line">HWND mainWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>), <span class="comment">// 创建哪个窗口，这里显然我们想要创建刚刚注册的那个窗口，这里传入的类名要和前面的一样</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>), <span class="comment">// 窗口的标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口的风格</span></span><br><span class="line"><span class="number">100</span>, <span class="comment">//窗口的位置数据，x,y,width,height</span></span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//这个窗口有没有父窗口（eg.QQ密码登陆错误，跳出来一个报错消息框，报错消息框是QQ登录窗口的子窗口） 没有就传NULL</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//这个窗口有没有菜单，没有传NULL</span></span><br><span class="line">hIns, <span class="comment">//这个窗口从属于哪个程序，传句柄</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//这个窗口有没有别的参数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子窗口</span></span><br><span class="line">WNDCLASS childWindow = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">childWindow.cbClsExtra = MYCLASSBUFFER;<span class="comment">//给窗口设定 class 缓冲区</span></span><br><span class="line">childWindow.cbWndExtra = MYWINDOWBUFFER;<span class="comment">//给窗口设定 window 缓冲区</span></span><br><span class="line">childWindow.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); <span class="comment">//给窗口设定颜色，这里是白色</span></span><br><span class="line">childWindow.hCursor = <span class="literal">NULL</span>; <span class="comment">//光标（Cursor）进入窗体时，使用默认光标，你也可以传进来一个图片</span></span><br><span class="line">childWindow.hIcon = <span class="literal">NULL</span>; <span class="comment">//窗体的Icon使用默认Icon，你也可以传进来一个图片</span></span><br><span class="line">childWindow.hInstance = hIns;<span class="comment">//窗口的程序句柄</span></span><br><span class="line">childWindow.lpfnWndProc = DefWindowProc;<span class="comment">//窗口处理函数，以便于回调</span></span><br><span class="line">childWindow.lpszClassName = <span class="built_in">TEXT</span>(<span class="string">&quot;Child&quot;</span>);<span class="comment">//窗口的类的名字</span></span><br><span class="line">childWindow.lpszMenuName = <span class="literal">NULL</span>; <span class="comment">//窗口的菜单的名字，NULL表示没有</span></span><br><span class="line">childWindow.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">//风格，为什么是常量通过与运算来确定，你点进常量里面看一看就懂了（Hint：二进制）。具体有哪些属性可以查微软API</span></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;childWindow);</span><br><span class="line">HWND childWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Child&quot;</span>),</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Child Window&quot;</span>),</span><br><span class="line">WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line">mainWindowHandle,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，创建了窗口!=窗口被操作系统显示，我们要调用函数让操作系统显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(</span><br><span class="line">mainWindowHandle,<span class="comment">//传入想要显示的窗口的句柄</span></span><br><span class="line">SW_SHOW <span class="comment">//显示的方法，具体可查API</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(mainWindowHandle); <span class="comment">//刷新窗口，不写也行，就是说明有这个玩意</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">消息循环</span></span><br><span class="line"><span class="comment">窗口程序之所以你不去点他他就一直存在，是因为存在消息循环一直在执行。</span></span><br><span class="line"><span class="comment">通过消息循环，整个程序不断地去检测你对整个程序干了些什么事情，然后对你的行动做出相应反应。</span></span><br><span class="line"><span class="comment">GetMessage返回值：</span></span><br><span class="line"><span class="comment">如果函数取得WM_QUIT之外的其他消息，返回非零值。</span></span><br><span class="line"><span class="comment">如果函数取得WM_QUIT消息，返回值是零。</span></span><br><span class="line"><span class="comment">如果出现了错误，返回值是-1。</span></span><br><span class="line"><span class="comment">若想获得更多的错误信息，请调用GetLastError函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MSG msgLoop = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(</span><br><span class="line">&amp;msgLoop, <span class="comment">// GetMessage向msgLoop丢消息</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 取得其消息的窗口的句柄。当其值取NULL时，GetMessage会去取我们写的程序的所有窗口发生的事件</span></span><br><span class="line"><span class="number">0</span>, <span class="comment">// 指定被检索的最小消息值，现在不用管这个</span></span><br><span class="line"><span class="number">0</span>  <span class="comment">// 指定被检索的最大消息值，现在不用管这个</span></span><br><span class="line">)) &#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msgLoop);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msgLoop);</span><br><span class="line"><span class="comment">// 分发消息，也就是交给WndProc来处理msg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Win32-GUI-编程-1-3-消息"><a href="#Win32-GUI-编程-1-3-消息" class="headerlink" title="Win32 GUI 编程 1.3 消息"></a>Win32 GUI 编程 1.3 消息</h2><h3 id="消息的概念与作用"><a href="#消息的概念与作用" class="headerlink" title="消息的概念与作用"></a>消息的概念与作用</h3><ul><li><p>消息的组成：</p><ul><li>窗口句柄</li><li>消息id</li><li>消息的两个参数</li><li>消息产生时间</li><li>消息产生时鼠标位置</li></ul></li><li><p>消息的作用</p><ul><li>当系统通知窗口工作时，就采用消息的方式派发给窗口</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMSG</span> &#123;</span><br><span class="line">    HWND hwnd;<span class="comment">//window handle</span></span><br><span class="line">    UINT message;<span class="comment">//msg</span></span><br><span class="line">    WPARAM wParam;<span class="comment">//w args</span></span><br><span class="line">    LPARAM lParam;<span class="comment">//l args</span></span><br><span class="line">    DWORD time;<span class="comment">//produce time</span></span><br><span class="line">    POINT pt;<span class="comment">//produce pointer direction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dispatch 分发机制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DispatchMessage</span>(&amp;nMsg) &#123;</span><br><span class="line">    nMsg.hwnd -&gt; 保存窗口数据的内存 -&gt; WndProc;<span class="comment">//通过窗口句柄找到窗口的内存地址</span></span><br><span class="line">    <span class="built_in">WndProc</span>(...nMsg) &#123;</span><br><span class="line">        <span class="comment">//调用窗口的WndProc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窗口处理函数（window Procedure Function）的原型（Prototype）<ul><li>只有满足这几个<strong>参数</strong>，才能称之为窗口处理函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd, <span class="comment">// 窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT uMsg, <span class="comment">//消息ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, <span class="comment">//args w</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam <span class="comment">//args l</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>窗口处理函数实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">mainWindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT msgID,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msgID) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTORY: <span class="comment">// 处理关闭事件</span></span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd,msgID,wParam,lParam); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见消息"><a href="#常见消息" class="headerlink" title="常见消息"></a>常见消息</h3><h4 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h4><ul><li><p>产生时间：窗口被销毁时</p></li><li><p>附带信息：</p><ul><li>wParam：0</li><li>lParam：0</li></ul></li><li><p>一般用法：常用于在窗口被销毁之前，做相应的处理（free…）</p></li></ul><h4 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h4><ul><li>产生时间：窗口系统区域发生事件时</li><li>附带信息：<ul><li>wParam：点击发生事件，例如：SC_CLOSE</li><li>lParam：鼠标光标的位置。<ul><li>LOWORD(lParam) 水平位置</li><li>HIWORD(lParam) 垂直位置</li></ul></li></ul></li></ul><h4 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h4><ul><li><p>产生时间：在窗口创建成功但是还未显示时。</p></li><li><p>附带信息：</p><ul><li>wParam：为0</li><li>lParam：为 CREATESTRUCT 类型的指针。通过这个指针可以反射CreateWindowEx的12个参数。</li></ul></li><li><p>一般用法：常用于初始化</p></li></ul><h4 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h4><ul><li><p>产生时间：在窗口的大小发生变化后。</p></li><li><p>附带信息：</p><ul><li>wParam：窗口大小发生变化的原因</li><li>lParam：窗口变化后的大小<ul><li>LOWORD(lParam) 变化后的宽度</li><li>HIWORD(lParam)变化后的高度</li></ul></li></ul></li><li><p>利用调试技巧：新增Console</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE g_hOutput = <span class="number">0</span>; <span class="comment">//作为static var</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在WinMain函数中：</span></span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AllocConsole</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在要输出内容的位置</span></span><br><span class="line"><span class="comment">//可以用sprintf格式化字符串</span></span><br><span class="line"><span class="built_in">WriteConsole</span>(g_hOutput,(text that you want to emit),<span class="built_in">strlen</span>(...),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h4><ul><li>产生时间：PostQuitMessage( integer );</li><li>附带信息：<ul><li>wParam:PostQuitMessage函数传递的参数</li><li>lParam:0</li></ul></li><li>一般用法:用于结束消息循环，当GetMessage收到这个消息后，退出消息循环。</li></ul><h4 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h4><ul><li><p>消息处理步骤</p><ul><li><p>开始绘图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">BeginPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd,<span class="comment">//绘图所在窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPPAINTSTRUCT lpPaint <span class="comment">//绘图参数缓存</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//返回绘图设备句柄HDC</span></span><br></pre></td></tr></table></figure></li><li><p>正式绘图</p></li><li><p>结束绘图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EndPaint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">CONST PAINTSTRUCT *lpPaint <span class="comment">//free pointer</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><h4 id="消息循环的阻塞"><a href="#消息循环的阻塞" class="headerlink" title="消息循环的阻塞"></a>消息循环的阻塞</h4><ul><li>PeekMessage - 以查看的方式从系统获取消息，可以不将消息从系统移除，非阻塞函数。当系统无消息时，返回false，继续执行后续代码。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPMSG lpMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wMsgFilterMin,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wMsgFilterMax,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT wRemoveMsg<span class="comment">//移除标识</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//PM_REMOVE/PM_NOREMOVE</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>GetMessage - 阻塞函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">PeekMessage</span>(&amp;nMsg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,PM_NOREMOVE)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">GetMessage</span>(&amp;nMsg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>(&amp;nMsg);</span><br><span class="line">            <span class="built_in">DispatchMessage</span>(&amp;nMsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息（emit）"><a href="#发送消息（emit）" class="headerlink" title="发送消息（emit）"></a>发送消息（emit）</h4><ul><li>SendMessage - 发送消息，并阻塞等候消息处理的结果。</li><li>PostMessage - 投递消息，消息发出后立即返回，不等候结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNIT msg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>系统消息 - ID范围 0-0x03ff</li><li>用户自定义消息 -  ID范围 0x0400 - 0x7FFF</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WM_MYMESSAGE WM_USER+...</span></span><br></pre></td></tr></table></figure><p>SendMessage ：直接内部调用窗口处理函数，不走消息循环</p><p>PostMessage：将消息加入消息队列。</p><h3 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h3><h4 id="键盘按下"><a href="#键盘按下" class="headerlink" title="键盘按下"></a>键盘按下</h4><ul><li>WM_KEYDOWN - 按键被按下时产生</li><li>WM_KETUP - 按键被放开时产生</li><li>WM_SYSKEYDOWN - 系统键被按下时产生（如ALT、F10）</li><li>WM_SYSKEYUP - 系统键放开时产生</li></ul><p>附带信息：</p><ul><li>WPARAM - 按键的 Virtual Key</li><li>LPARAM - 按键的参数，例如按下了几次</li></ul><p><strong>虚拟键码（Virtual Key）不等于输入内容</strong></p><h4 id="字符消息"><a href="#字符消息" class="headerlink" title="字符消息"></a>字符消息</h4><ul><li>TranslateMessage 在转换 WM_KEYDOWN 消息时，对于可见字符产生一个WM_CHAR的事件，如果按下不可见字符则无此消息</li><li>附带信息：<ul><li>WPARAM - 输入的字符的 ASCII 字符编码</li><li>LPARAM - 输入的按键的相关参数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">onKeyDown</span><span class="params">(HWND hWnd, WPARAM wParam)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf_s</span>(szText, <span class="string">&quot;WM_KEYDOWN:virtual key: %d\n&quot;</span>, wParam);</span><br><span class="line"><span class="built_in">WriteConsole</span>(g_hOutput, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onKeyUp</span><span class="params">(HWND hWnd, WPARAM wParam)</span> </span>&#123;</span><br><span class="line"><span class="built_in">onKeyDown</span>(hWnd, wParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onProdChar</span><span class="params">(HWND hWnd,WPARAM wParam)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> szText[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf_s</span>(szText, <span class="string">&quot;WM_CHAR:%c\n&quot;</span>, (<span class="type">char</span>)wParam);</span><br><span class="line"><span class="built_in">WriteConsole</span>(g_hOutput, szText, <span class="built_in">strlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">// 传入某个窗口的句柄，操作系统告诉你是哪个窗口遇到了需要处理的事件</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT msgID, <span class="comment">// 传入窗口发生的事件，操作系统告诉你当前窗口发生了什么事情</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, <span class="comment">//附加参数 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam <span class="comment">//附加参数 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line"><span class="comment">//PostQuitMessage(0);</span></span><br><span class="line"><span class="built_in">PostMessage</span>(hWnd, WM_QUIT, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line"><span class="built_in">onKeyDown</span>(hWnd, wParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line"><span class="built_in">onKeyUp</span>(hWnd, wParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line"><span class="built_in">onProdChar</span>(hWnd, wParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h3><ul><li><p>基本鼠标消息：</p><p>WM_LBUTTONDOWN - 鼠标左键按下</p><p>WM_LBUTTONUP - 鼠标左键抬起</p><p>WM_RBUTTONDOWN - 鼠标右键按下</p><p>WM_RBUTTONUP - 鼠标右键抬起</p><p>WM_MOUSEMOVE - 鼠标移动消息</p></li><li><p>双击消息</p><p>WM_LBUTTONDBLCLK - 鼠标左键双击</p><p>WM_RBUTTONDBLCLK - 鼠标右键双击</p></li><li><p>滚轮消息</p><p>WM_MOUSEWHEEL - 鼠标滚轮消息</p></li><li><p>附带消息：</p><p>wParam ：其他button的状态，例如ctrl&#x2F;shift</p><p>lParam：鼠标的位置</p></li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>产生时间：</p><p>在程序中创建定时器，当到达时间间隔时，定时器会向程序发送信息。定时器的精度是ms，但是准确度很低。</p></li><li><p>附带信息：</p><p>wParam：定时器ID</p><p>lParam：定时器处理函数的指针</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">//定时器窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR nIDEvent <span class="comment">//定时器ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uElapse, <span class="comment">//时间间隔</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TIMERPROC lpTimerFunc <span class="comment">//定时器处理函数，可以为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd, <span class="comment">//定时器窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT_PTR uIDEvent <span class="comment">//定时器id</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="built_in">SetTimer</span>(hWnd, <span class="number">1</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SetTimer</span>(hWnd, <span class="number">2</span>, <span class="number">2000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_TIMER:</span><br><span class="line"><span class="built_in">OnTimer</span>(hWnd, wParam);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnTimer</span><span class="params">(HWND hWnd, WPARAM wParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (wParam) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">WriteConsole</span>(g_hOutput, <span class="string">&quot;Timer1\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Timer1\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">WriteConsole</span>(g_hOutput, <span class="string">&quot;Timer2\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Timer2\n&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Win32-GUI-编程-2-1-资源"><a href="#Win32-GUI-编程-2-1-资源" class="headerlink" title="Win32 GUI 编程 2.1 资源"></a>Win32 GUI 编程 2.1 资源</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul><li>资源脚本文件：*.rc 文件</li><li>编译器：RC.exe</li></ul><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><h4 id="菜单类型"><a href="#菜单类型" class="headerlink" title="菜单类型"></a>菜单类型</h4><ul><li>窗口的顶层菜单</li><li>弹出式菜单</li><li>系统菜单</li></ul><p>HMEMU：菜单句柄</p><p>ID：菜单项</p><h4 id="菜单的装载"><a href="#菜单的装载" class="headerlink" title="菜单的装载"></a>菜单的装载</h4><ul><li><p>添加菜单资源</p></li><li><p>visual studio有图形化界面</p></li><li><p>加载菜单资源</p><ul><li><p>注册窗口类时设置菜单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.lpszMenuName = (<span class="type">char</span>*)IDR_MENU;</span><br></pre></td></tr></table></figure></li><li><p>创建窗口传参设置菜单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HMENU mainWindowMenu = <span class="built_in">LoadMenu</span>(</span><br><span class="line">hIns, <span class="comment">//current thread handle</span></span><br><span class="line">(LPCTSTR)IDR_MENU <span class="comment">// resource identifier</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HWND mainWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>), <span class="comment">// 创建哪个窗口，这里显然我们想要创建刚刚注册的那个窗口，这里传入的类名要和前面的一样</span></span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>), <span class="comment">// 窗口的标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口的风格</span></span><br><span class="line"><span class="number">100</span>, <span class="comment">//窗口的位置数据，x,y,width,height</span></span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//这个窗口有没有父窗口（eg.QQ密码登陆错误，跳出来一个报错消息框，报错消息框是QQ登录窗口的子窗口） 没有就传NULL</span></span><br><span class="line">mainWindowMenu, <span class="comment">//这个窗口有没有菜单，没有传NULL，有传入菜单句柄</span></span><br><span class="line">hIns, <span class="comment">//这个窗口从属于哪个程序，传句柄</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//这个窗口有没有别的参数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在主窗口 WM_CREATE 消息中利用 SetMenu 设置菜单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetMenu</span>(HWND hWnd,HMENU hMenu);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="菜单事件监听"><a href="#菜单事件监听" class="headerlink" title="菜单事件监听"></a>菜单事件监听</h4><p>事件名称：WM_COMMAND</p><p>LOWORD(wParam)：点击的菜单项的id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">onCommand</span><span class="params">(HWND hWnd, WPARAM wParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//LOWORD(wParam) indicate id of tab that has been clicked</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line"><span class="keyword">case</span> ID_FILE_EXIT:</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_FILE_CREATE:</span><br><span class="line"><span class="built_in">MessageBox</span>(</span><br><span class="line">hWnd,</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;We have not yet fulfill this&quot;</span>),</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;sumimase!&quot;</span>),</span><br><span class="line">MB_OK</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图标资源"><a href="#图标资源" class="headerlink" title="图标资源"></a>图标资源</h3><ul><li><p>添加图标资源：visual studio有成型的方案</p></li><li><p>加载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HICON <span class="title">LoadIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpIconName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设置：注册窗口类</p></li></ul><h3 id="字符串资源"><a href="#字符串资源" class="headerlink" title="字符串资源"></a>字符串资源</h3><ul><li><p>添加字符串资源：添加字符串表</p></li><li><p>字符串资源引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LoadString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT uID, <span class="comment">//字符串id</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPTSTR lpBuffer, <span class="comment">//存放字符串的buffer char*</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nBufferMax <span class="comment">//字符串buffer长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Win32-GUI-编程-2-2-绘图"><a href="#Win32-GUI-编程-2-2-绘图" class="headerlink" title="Win32 GUI 编程 2.2 绘图"></a>Win32 GUI 编程 2.2 绘图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>绘图设备 - DC（Device Context） ，绘图上下文、绘图描述表</p></li><li><p>HDC - DC句柄，表示绘图设备</p></li><li><p>GDI - Windows graphics device interface （Win32 提供的绘图API）</p></li><li><p>颜色：</p><ul><li>R - red</li><li>G - green</li><li>B - blue</li></ul></li><li><p>颜色的使用</p><p>COLORREF - 实际DWORD</p><p>例如：COLORREF nColor &#x3D; 0;</p></li><li><p>赋值使用RGB宏</p><p>例如：nColor &#x3D; RGB(0,0,225);</p></li><li><p>获取RGB值：</p><p>GetRValue….</p><p>BYTE nRed &#x3D; GetRValue( nColor );</p></li></ul><h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><ul><li><p>SetPixel 设置指定点的颜色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetPixel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HDC hdc,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> X,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> Y,</span></span></span><br><span class="line"><span class="params"><span class="function">COLORREF crColor</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPit</span><span class="params">(HDC hdc)</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetPixel</span>(hdc, <span class="number">100</span>, <span class="number">100</span>, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onFirstPaint</span><span class="params">(HWND hWnd)</span> </span>&#123;</span><br><span class="line">PAINTSTRUCT nowWindowPaint = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HDC handlePaint = <span class="built_in">BeginPaint</span>(hWnd, &amp;nowWindowPaint);</span><br><span class="line"><span class="built_in">drawPit</span>(handlePaint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口处理函数（自定义，处理消息）</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT msgID,</span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam, </span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam </span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line"><span class="built_in">onFirstPaint</span>(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线的使用（Line，Curve）</p><p>MoveToEx - 指向窗口当前点</p><p>LineTo - 从窗口当前点到指定点绘制一条直线</p><p>当前点：上次绘图时的最后一点，初始为（0，0）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(HDC hdc)</span> </span>&#123;</span><br><span class="line"><span class="built_in">MoveToEx</span>(</span><br><span class="line">hdc, <span class="comment">// handle DC</span></span><br><span class="line"><span class="number">100</span>, <span class="comment">// X</span></span><br><span class="line"><span class="number">100</span>, <span class="comment">// Y</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">// getLastPit</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">LineTo</span>(hdc, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onFirstPaint</span><span class="params">(HWND hWnd)</span> </span>&#123;</span><br><span class="line">PAINTSTRUCT nowWindowPaint = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HDC handlePaint = <span class="built_in">BeginPaint</span>(hWnd, &amp;nowWindowPaint);</span><br><span class="line"><span class="comment">//drawPit(handlePaint);</span></span><br><span class="line"><span class="built_in">drawLine</span>(handlePaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封闭图形：能够用画刷填充的图形</p><p>Rectangle，Eclipse</p></li></ul><h3 id="GDI绘图对象-画笔"><a href="#GDI绘图对象-画笔" class="headerlink" title="GDI绘图对象 - 画笔"></a>GDI绘图对象 - 画笔</h3><ul><li><p>画笔的作用</p><p>线的颜色、线的形状、线的粗细</p><p>HPEN - 画笔句柄</p></li><li><p>画笔的使用</p><p>1、创建画笔</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HPEN <span class="title">CreatePen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> fnPenStyle, <span class="comment">//画笔的样式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nWidth, <span class="comment">//画笔的粗细</span></span></span></span><br><span class="line"><span class="params"><span class="function">COLORREF crColor <span class="comment">// 颜色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//创建成功返回句柄</span></span><br></pre></td></tr></table></figure><p>2、HDC 绑定 HPEN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HGDIOBJ <span class="title">SelectObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HDC hdc, <span class="comment">// 绘图设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">HGDIOBJ hgdiobj<span class="comment">//GDI绘图对象句柄 - 画笔句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">//返回原来的GDI绘图对象句柄 - 原来的画笔句柄</span></span><br></pre></td></tr></table></figure><p>HGDIOBJ - Handle of GDI object</p><p>GDI - Graphic Device Interface</p><p>3、绘图</p><p>4、取出画笔（用SelectObject，将原来的画笔还回去）</p><p>5、释放画笔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL DeleteObject(</span><br><span class="line">HGDIOBJ hObject //GDI绘图对象句柄 - 画笔句柄</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="GDI绘图对象-画刷"><a href="#GDI绘图对象-画刷" class="headerlink" title="GDI绘图对象 - 画刷"></a>GDI绘图对象 - 画刷</h3><ul><li><p>画刷相关</p><p>画刷 - 封闭突匈的填充的颜色、pattern</p><p>HBRUSH - 画刷句柄</p></li><li><p>画刷的使用</p><p>1 创建画刷</p><ul><li>CreateSolidBrush - 创建实心画刷</li><li>CreateHatchBrush - 创建纹理画刷</li></ul><p>2 将画刷应用到DC中</p><ul><li>SelectObject</li></ul><p>3 绘图</p><p>4 将画刷取出</p><ul><li>SelectObject</li></ul><p>5 删除画刷</p><ul><li>DeleteObject</li></ul></li><li><p>注意：Device Context既有刷子又有画笔</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">onFirstPaint</span><span class="params">(HWND hWnd)</span> </span>&#123;</span><br><span class="line">PAINTSTRUCT nowWindowPaint = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HDC handlePaint = <span class="built_in">BeginPaint</span>(hWnd, &amp;nowWindowPaint);</span><br><span class="line"></span><br><span class="line">HPEN hPen = <span class="built_in">CreatePen</span>(</span><br><span class="line">PS_SOLID, <span class="comment">//Pen style</span></span><br><span class="line"><span class="number">1</span>, <span class="comment">// Pen width</span></span><br><span class="line"><span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">//Pen color</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HBRUSH hBrush = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">HGDIOBJ nOldBrush = <span class="built_in">SelectObject</span>(</span><br><span class="line">handlePaint,</span><br><span class="line">hBrush</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HGDIOBJ nOldPen = <span class="built_in">SelectObject</span>(</span><br><span class="line">handlePaint, <span class="comment">//Handle of Device Context</span></span><br><span class="line">hPen <span class="comment">// New Pen</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawPit(handlePaint);</span></span><br><span class="line"><span class="comment">//drawLine(handlePaint);</span></span><br><span class="line"><span class="built_in">drawRect</span>(handlePaint);</span><br><span class="line"><span class="built_in">drawEll</span>(handlePaint);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SelectObject</span>(handlePaint, nOldPen);</span><br><span class="line"><span class="built_in">SelectObject</span>(handlePaint, nOldBrush);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hPen);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hBrush);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以用GetStockObject函数获取系统维护的画刷、画笔等。</p><p>如果不使用画刷填充，余姚使用NULL_BRUSH参数，获取不填充的画刷。</p><p>GetStockObject返回的画刷不需要DeleteObject。</p></li></ul><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><h4 id="位图绘制"><a href="#位图绘制" class="headerlink" title="位图绘制"></a>位图绘制</h4><ul><li><p>位图概念</p><p><strong>光栅图形 - 保存图像中每一个颜色的信息（位图）</strong></p><p>矢量图形 - 记录图像算法</p><p>HBITMAP - 位图句柄</p></li><li><p>位图的使用</p><p>1 在资源中添加位图</p><p>2 从资源中加载位图LoadBitmap</p><p>3 创建一个与当前DC相匹配的DC（Memory_DC）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">CreateCompatibleDC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HDC hdc <span class="comment">//当前DC句柄，可以为NULL(使用屏幕DC)</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//返回创建好的DC</span></span><br></pre></td></tr></table></figure><p>注意：当前DC是直接在屏幕上画图，CreateCompatibleDC创建出来的DC是在内存里面画图</p><p>4 将位图放入匹配的DC中 SelectObject</p><p>5 成像（1：1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">bitBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HDC hdcDest, <span class="comment">//Destination</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nXDest,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nYDest,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nWidth,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">HDC hdcSrc, <span class="comment">//Source</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nXSrc,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nYSrc,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwRop <span class="comment">// 成像方法 如SRCCOPY</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>6 取出位图</p><p>7 释放位图、Memory_DC</p></li><li><p>缩放位图：StretchBlt</p></li></ul><h2 id="Win32-GUI-编程-3-1-常用系统窗口类（标准控件）"><a href="#Win32-GUI-编程-3-1-常用系统窗口类（标准控件）" class="headerlink" title="Win32 GUI 编程 3.1 常用系统窗口类（标准控件）"></a>Win32 GUI 编程 3.1 常用系统窗口类（标准控件）</h2><p>完整文档，请访问：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/controls/window-controls">https://docs.microsoft.com/en-us/windows/win32/controls/window-controls</a></p><p>提示：找到左边的 Control Library，点进去。</p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>窗口类标签：Button</p><p>创建一个按钮：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND hwndButton = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="string">L&quot;Button&quot;</span>,</span><br><span class="line"><span class="string">L&quot;Submit&quot;</span>,</span><br><span class="line">WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON | WS_VISIBLE,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">50</span>,</span><br><span class="line">mainWindowHandle,</span><br><span class="line">(HMENU)<span class="number">1001</span>, <span class="comment">//对于子组件，hmenu的值作为id让父窗口区分</span></span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于子窗口，HMENU 的值可以被父窗口调用。</p><h4 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h4><p>按钮向消息队列中发送 Notification ，收信的是父窗口。</p><p>父窗口监听 WM_COMMAND 事件，以上面代码生成的按钮为例子，此按钮被点击后，生成 WM_COMMAND事件发送给父窗口；</p><p>LOWORD(wParam) &#x3D; 1001 (对于子组件，hmenu的值作为id让父窗口区分)</p><p>HIWORD(wParam) &#x3D; BN_CLICKED</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1001</span>:</span><br><span class="line"><span class="comment">//do something ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><h4 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h4><p>窗口类标签：ComboBox</p><p>创建一个复选框：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND hWndComboBox = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;ComboBox&quot;</span>),</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line">mainWindowHandle,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="添加选择项"><a href="#添加选择项" class="headerlink" title="添加选择项"></a>添加选择项</h4><p>ComboBox可以通过：（二选一）</p><ul><li>SendMessage 发送CB_ADDSTRING 消息</li><li>调用 ComboBox_AddString 函数（需要 #include&lt;windowsx.h&gt; ）</li></ul><p>这两种方式添加可选择项</p><h4 id="获得目前被选择项"><a href="#获得目前被选择项" class="headerlink" title="获得目前被选择项"></a>获得目前被选择项</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> selectionComboBox = <span class="built_in">SendMessage</span>(g_hWndComboBox, CB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>SendMessage：CB_GETCURSEL。</p><p>返回的是目前被选中的项目的数字编号（第一个被选中返回0，第二个被选中返回1，以此类推）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windowsx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPCTSTR labelComboBox[<span class="number">6</span>] = &#123;</span><br><span class="line"><span class="string">L&quot;巨佬A&quot;</span>,</span><br><span class="line"><span class="string">L&quot;巨佬B&quot;</span>,</span><br><span class="line"><span class="string">L&quot;巨佬C&quot;</span>,</span><br><span class="line"><span class="string">L&quot;巨佬D&quot;</span>,</span><br><span class="line"><span class="string">L&quot;巨佬E&quot;</span>,</span><br><span class="line"><span class="string">L&quot;巨佬F&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HWND g_hWndButtonSubmit = <span class="number">0</span>;</span><br><span class="line">HWND g_hWndComboBox = <span class="number">0</span>;</span><br><span class="line">HANDLE g_console = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT msgID,</span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgID) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1001</span>:</span><br><span class="line"><span class="type">int</span> selectionComboBox = <span class="built_in">SendMessage</span>(g_hWndComboBox, CB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">LPCTSTR showWord = <span class="string">L&quot;you didn&#x27;t choose&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (selectionComboBox != CB_ERR)</span><br><span class="line">showWord = labelComboBox[selectionComboBox];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HIWORD</span>(wParam) == BN_CLICKED) &#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(</span><br><span class="line">hWnd,</span><br><span class="line">showWord,</span><br><span class="line"><span class="string">L&quot;the people you choose is ...&quot;</span>,</span><br><span class="line">MB_OK</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, msgID, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWINDOWBUFFER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASSBUFFER 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> CALLBACK <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hIns, </span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPerIns,</span></span></span><br><span class="line"><span class="params"><span class="function">LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"><span class="built_in">AllocConsole</span>();</span><br><span class="line">g_console = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">WNDCLASS mainWindow = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mainWindow.cbClsExtra = MYCLASSBUFFER;</span><br><span class="line">mainWindow.cbWndExtra = MYWINDOWBUFFER;</span><br><span class="line">mainWindow.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>); </span><br><span class="line">mainWindow.hCursor = <span class="literal">NULL</span>; </span><br><span class="line">mainWindow.hIcon = <span class="literal">NULL</span>; </span><br><span class="line">mainWindow.hInstance = hIns;</span><br><span class="line">mainWindow.lpfnWndProc = WndProc;</span><br><span class="line">mainWindow.lpszClassName = <span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">mainWindow.lpszMenuName = <span class="literal">NULL</span>; </span><br><span class="line">mainWindow.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;mainWindow);</span><br><span class="line"></span><br><span class="line">HWND mainWindowHandle = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Main&quot;</span>), </span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;Hello World!&quot;</span>), </span><br><span class="line">WS_OVERLAPPEDWINDOW,</span><br><span class="line"><span class="number">100</span>, </span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="number">500</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">HWND hWndComboBox = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;ComboBox&quot;</span>),</span><br><span class="line"><span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD | WS_OVERLAPPED | WS_VISIBLE,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line">mainWindowHandle,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">g_hWndComboBox = hWndComboBox;</span><br><span class="line"></span><br><span class="line">HWND hwndButton = <span class="built_in">CreateWindow</span>(</span><br><span class="line"><span class="string">L&quot;Button&quot;</span>,</span><br><span class="line"><span class="string">L&quot;Submit&quot;</span>,</span><br><span class="line">WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON | WS_VISIBLE,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">50</span>,</span><br><span class="line">mainWindowHandle,</span><br><span class="line">(HMENU)<span class="number">1001</span>, <span class="comment">//对于子组件，hmenu的值作为id让父窗口区分</span></span><br><span class="line">hIns,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">g_hWndButtonSubmit = hwndButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="built_in">ComboBox_AddString</span>(hWndComboBox, labelComboBox[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ShowWindow</span>(</span><br><span class="line">mainWindowHandle,</span><br><span class="line">SW_SHOW</span><br><span class="line">);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(mainWindowHandle);</span><br><span class="line"></span><br><span class="line">MSG msgLoop = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(</span><br><span class="line">&amp;msgLoop,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">)) &#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msgLoop);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msgLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
